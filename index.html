<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <title>Mapa Din&aacute;mico SNIEn</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.css" />
    <link rel="stylesheet" href="css/main.css" />
</head>

<body>
    <div id="preloader">
        <div class="preloader-content" role="status" aria-live="polite">
            <div class="spinner"></div>
            <p>Cargando informaci&oacute;n geoespacial...</p>
        </div>
    </div>

    <header class="site-header">
        <div class="container header-content">
            <div class="brand">
                <div class="brand-logos">
                    <img src="img/logo_sener.png" alt="Logo SENER" class="brand-logo brand-logo--sener" />
                    <img src="img/snien.png" alt="Logo Sistema Nacional de Informaci√≥n Energ√©tica"
                        class="brand-logo brand-logo--snien" />
                </div>
                <div class="brand-copy">
                    <span class="brand-eyebrow">Secretar&iacute;a de Energ&iacute;a</span>
                    <span class="brand-title">Mapa din&aacute;mico SNIEn</span>
                </div>
            </div>
            <div class="header-meta">
                <span class="meta-label">Actualizaci&oacute;n</span>
                <span id="last-updated" class="meta-value">--</span>
            </div>
        </div>
    </header>

    <main class="page-content">
        <section class="map-section">
            <div class="container">
                <div class="map-card">
                    <div class="card-toolbar">
                        <div class="toolbar-group">
                            <button type="button" id="refresh-data" class="btn-secondary">Actualizar datos</button>
                        </div>
                        <div class="toolbar-group">
                            <label>Exportar mapa</label>
                            <div class="export-buttons">
                                <button type="button" id="export-pdf" class="btn-export btn-export--pdf"
                                    title="Exportar como PDF">
                                    <span class="btn-export__icon">üìÑ</span>
                                    <span class="btn-export__text">PDF</span>
                                </button>
                                <button type="button" id="export-png" class="btn-export btn-export--png"
                                    title="Exportar como PNG">
                                    <span class="btn-export__icon">üñºÔ∏è</span>
                                    <span class="btn-export__text">PNG</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div id="map" class="map-view" role="region" aria-label="Mapa interactivo del SNIEn"></div>
                    <div class="card-footer">
                        <p class="data-source">
                            Fuente de datos: Hoja de c&aacute;lculo institucional publicada (Google Sheets).
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <section class="info-section">
            <div class="container info-grid">
                <article class="info-panel">
                    <h2>Prop&oacute;sito</h2>
                    <p>
                        Este geovisor permite visualizar capas del Sistema Nacional de Informaci&oacute;n
                        Energ&eacute;tica con
                        mapas base personalizados MapTiler y datos abiertos que se actualizan desde Google Sheets.
                    </p>
                </article>
                <article class="info-panel">
                    <h3>Recomendaciones de uso</h3>
                    <ul>
                        <li>Usa el control de capas en el mapa para cambiar el mapa base y activar/desactivar capas.
                        </li>
                        <li>Usa la acci&oacute;n &ldquo;Actualizar datos&rdquo; tras editar la hoja de c&aacute;lculo.
                        </li>
                        <li>Acerca o aleja el mapa hasta el detalle deseado; el visor mantiene el enfoque en
                            M&eacute;xico.</li>
                        <li>Exporta el mapa en PDF o PNG con las configuraciones que necesites.</li>
                    </ul>
                </article>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <div class="container footer-content">
            <div class="footer-logos">
                <img src="img/logo_gob.png" alt="Gobierno de M&eacute;xico" />
                <img src="img/logo_sener.png" alt="Secretar&iacute;a de Energ&iacute;a" />
            </div>
            <p>Sistema Nacional de Informaci&oacute;n Energ&eacute;tica &middot; Secretar&iacute;a de Energ&iacute;a</p>
        </div>
    </footer>

    <!-- Modal de configuraci√≥n de exportaci√≥n -->
    <div id="export-modal" class="modal" role="dialog" aria-labelledby="export-modal-title" aria-hidden="true">
        <div class="modal-overlay" aria-hidden="true"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="export-modal-title" class="modal-title">Configurar exportaci√≥n</h3>
                <button type="button" class="modal-close" aria-label="Cerrar modal">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <form id="export-config-form" class="export-form">
                    <div class="form-section">
                        <h4 class="form-section-title">Formato de archivo</h4>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="format" value="pdf" checked>
                                <span class="radio-custom"></span>
                                <span class="radio-label">PDF - Para impresi√≥n y documentos</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="format" value="png">
                                <span class="radio-custom"></span>
                                <span class="radio-label">PNG - Para presentaciones digitales</span>
                            </label>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4 class="form-section-title">Tama√±o y resoluci√≥n</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="page-size">Tama√±o de p√°gina</label>
                                <select id="page-size" name="pageSize" class="control">
                                    <option value="A4">A4 (210 √ó 297 mm)</option>
                                    <option value="A3">A3 (297 √ó 420 mm)</option>
                                    <option value="Letter">Carta (216 √ó 279 mm)</option>
                                    <option value="custom">Personalizado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="dpi-select">Resoluci√≥n (DPI)</label>
                                <select id="dpi-select" name="dpi" class="control">
                                    <option value="150">150 DPI - Calidad est√°ndar</option>
                                    <option value="300" selected>300 DPI - Alta calidad</option>
                                    <option value="600">600 DPI - M√°xima calidad</option>
                                </select>
                            </div>
                        </div>

                        <div id="custom-size-section" class="form-row custom-size-section" style="display: none;">
                            <div class="form-group">
                                <label for="custom-width">Ancho (p√≠xeles)</label>
                                <input type="number" id="custom-width" name="customWidth" class="control" min="100"
                                    max="8000" value="2480">
                            </div>
                            <div class="form-group">
                                <label for="custom-height">Alto (p√≠xeles)</label>
                                <input type="number" id="custom-height" name="customHeight" class="control" min="100"
                                    max="8000" value="3508">
                            </div>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4 class="form-section-title">Elementos a incluir</h4>
                        <div class="checkbox-group">
                            <label class="checkbox-option">
                                <input type="checkbox" name="includeScale" checked>
                                <span class="checkbox-custom"></span>
                                <span class="checkbox-label">Escala del mapa</span>
                            </label>
                            <label class="checkbox-option">
                                <input type="checkbox" name="includeLegend" checked>
                                <span class="checkbox-custom"></span>
                                <span class="checkbox-label">Leyenda</span>
                            </label>
                            <label class="checkbox-option">
                                <input type="checkbox" name="includeAttribution" checked>
                                <span class="checkbox-custom"></span>
                                <span class="checkbox-label">Atribuciones y fuentes</span>
                            </label>
                            <label class="checkbox-option">
                                <input type="checkbox" name="includeTimestamp" checked>
                                <span class="checkbox-custom"></span>
                                <span class="checkbox-label">Fecha y hora de generaci√≥n</span>
                            </label>
                            <label class="checkbox-option">
                                <input type="checkbox" name="includeTitle" checked>
                                <span class="checkbox-custom"></span>
                                <span class="checkbox-label">T√≠tulo del mapa</span>
                            </label>
                        </div>
                    </div>

                    <div class="form-section">
                        <h4 class="form-section-title">Informaci√≥n adicional</h4>
                        <div class="form-group">
                            <label for="map-title">T√≠tulo personalizado (opcional)</label>
                            <input type="text" id="map-title" name="mapTitle" class="control"
                                placeholder="Mapa SNIEn - Sistema Nacional de Informaci√≥n Energ√©tica">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary btn-cancel">Cancelar</button>
                <button type="button" class="btn-secondary btn-export-confirm">
                    <span class="btn-text">Exportar</span>
                    <span class="btn-spinner" style="display: none;">
                        <span class="spinner-small"></span>
                    </span>
                </button>
            </div>
        </div>
    </div>

    <!-- Sistema de notificaciones -->
    <div id="notification-container" class="notification-container" aria-live="polite" aria-atomic="true"></div>

    <!-- Overlay de progreso global -->
    <div id="export-progress-overlay" class="progress-overlay" style="display: none;">
        <div class="progress-content">
            <div class="progress-spinner"></div>
            <h4 class="progress-title">Exportando mapa...</h4>
            <p class="progress-message">Capturando imagen del mapa</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <p class="progress-percentage">0%</p>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.umd.min.js"></script>
    <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.1.0/leaflet-maptilersdk.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Export dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-image@0.4.0/leaflet-image.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <!-- Map Export Module -->
    <script>
        /**
         * Configuraci√≥n de exportaci√≥n para mapas
         */
        class ExportConfiguration {
            constructor(options = {}) {
                this.format = options.format || 'png';
                this.size = {
                    preset: options.size?.preset || 'A4',
                    width: options.size?.width || 2480,
                    height: options.size?.height || 3508,
                    dpi: options.size?.dpi || 300
                };
                this.elements = {
                    includeScale: options.elements?.includeScale !== false,
                    includeLegend: options.elements?.includeLegend !== false,
                    includeAttribution: options.elements?.includeAttribution !== false,
                    includeTimestamp: options.elements?.includeTimestamp !== false,
                    includeTitle: options.elements?.includeTitle !== false
                };
                this.metadata = {
                    title: options.metadata?.title || 'Mapa SNIEn',
                    author: options.metadata?.author || 'SENER',
                    subject: options.metadata?.subject || 'Mapa del Sistema Nacional de Informaci√≥n Energ√©tica',
                    creator: options.metadata?.creator || 'SNIEn - SENER'
                };
            }
        }

        /**
         * Capturador de canvas del mapa Leaflet
         */
        class CanvasCapture {
            constructor(map) {
                this.map = map;
                this.maxWaitTime = 10000; // 10 segundos m√°ximo de espera
                this.tileCheckInterval = 100; // Verificar cada 100ms
            }

            /**
             * Captura el mapa actual como imagen
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Promise<HTMLCanvasElement>} Canvas con la imagen del mapa
             */
            async captureMap(config) {
                try {
                    // Validar que el mapa est√© en estado v√°lido
                    this.validateMapState();

                    // Preparar elementos de la interfaz para captura
                    const uiState = await this.prepareUIForCapture(config);

                    // Esperar a que todos los tiles est√©n cargados antes de capturar
                    await this.waitForTilesToLoad();

                    // Asegurar que los marcadores est√©n visibles y listos
                    await this.ensureMarkersReady();

                    // Capturar el mapa usando leaflet-image
                    const canvas = await this.performCapture();

                    // Restaurar estado original de la interfaz
                    await this.restoreUIState(uiState);

                    return canvas;
                } catch (error) {
                    throw new Error('Error en la captura del mapa: ' + error.message);
                }
            }

            /**
             * Espera a que todos los tiles del mapa est√©n completamente cargados
             * @returns {Promise<void>}
             */
            async waitForTilesToLoad() {
                return new Promise((resolve, reject) => {
                    const startTime = Date.now();
                    let checkCount = 0;

                    const checkTiles = () => {
                        checkCount++;
                        const elapsed = Date.now() - startTime;

                        // Verificar si ha pasado el tiempo m√°ximo de espera
                        if (elapsed > this.maxWaitTime) {
                            console.warn(`Timeout esperando tiles despu√©s de ${elapsed}ms (${checkCount} verificaciones) - procediendo con la captura`);
                            resolve();
                            return;
                        }

                        // Obtener estado actual de tiles
                        const tilesLoaded = this.areAllTilesLoaded();
                        const status = this.getTileLoadingStatus();

                        if (checkCount % 10 === 0) { // Log cada segundo aproximadamente
                            console.log(`Verificaci√≥n ${checkCount}: ${status.loadedTiles}/${status.totalTiles} tiles cargados`);
                        }

                        // Verificar si todos los tiles est√°n cargados
                        if (tilesLoaded) {
                            console.log(`Todos los tiles cargados despu√©s de ${elapsed}ms (${checkCount} verificaciones)`);
                            resolve();
                        } else {
                            // Continuar verificando
                            setTimeout(checkTiles, this.tileCheckInterval);
                        }
                    };

                    console.log('Iniciando espera de carga de tiles...');
                    checkTiles();
                });
            }

            /**
             * Verifica si todos los tiles del mapa est√°n cargados
             * @returns {boolean} True si todos los tiles est√°n cargados
             */
            areAllTilesLoaded() {
                let allLoaded = true;

                // Iterar sobre todas las capas del mapa
                this.map.eachLayer((layer) => {
                    // Verificar si es una capa de tiles
                    if (layer instanceof L.TileLayer) {
                        // Verificar el estado de carga de los tiles
                        const container = layer.getContainer();
                        if (container) {
                            const tiles = container.querySelectorAll('img');
                            tiles.forEach((tile) => {
                                // Si alg√∫n tile no est√° completamente cargado
                                if (!tile.complete || tile.naturalWidth === 0) {
                                    allLoaded = false;
                                }
                            });
                        }
                    }

                    // Verificar capas de MapTiler espec√≠ficamente
                    if (layer._maptilerLayer || (layer.options && layer.options.style)) {
                        // Para capas de MapTiler, verificar si est√°n en estado de carga
                        if (layer._loading || (layer._tiles && Object.keys(layer._tiles).length === 0)) {
                            allLoaded = false;
                        }
                    }

                    // Verificar marcadores con iconos de imagen
                    if (layer instanceof L.Marker && layer._icon) {
                        const img = layer._icon.querySelector('img');
                        if (img && (!img.complete || img.naturalWidth === 0)) {
                            allLoaded = false;
                        }
                    }
                });

                return allLoaded;
            }

            /**
             * Realiza la captura del mapa usando API de imagen est√°tica de MapTiler
             * @returns {Promise<HTMLCanvasElement>}
             */
            async performCapture() {
                return new Promise(async (resolve, reject) => {
                    try {
                        console.log('Iniciando captura con cambio temporal de mapa base...');

                        // Cambiar temporalmente a un mapa base sin CORS
                        const originalInfo = await this.switchToExportFriendlyBasemap();

                        try {
                            // Esperar a que el nuevo mapa base se cargue completamente
                            await this.waitForTilesToLoad();

                            // Capturar con leaflet-image (ahora deber√≠a funcionar sin CORS)
                            const canvas = await this.performSimpleCapture();

                            // Restaurar el mapa base original
                            await this.restoreOriginalBasemap(originalInfo);

                            console.log('Captura exitosa con cambio temporal de mapa base');
                            resolve(canvas);

                        } catch (captureError) {
                            console.warn('Error en captura, restaurando mapa base:', captureError);

                            // Asegurar que se restaure el mapa base original
                            await this.restoreOriginalBasemap(originalInfo);

                            // Intentar captura b√°sica como √∫ltimo recurso
                            const basicCanvas = await this.createBasicMapCanvas();
                            resolve(basicCanvas);
                        }

                    } catch (error) {
                        console.error('Error en captura con cambio de mapa base:', error);
                        reject(new Error('No se pudo capturar el mapa: ' + error.message));
                    }
                });
            }

            /**
             * Cambia temporalmente a un mapa base compatible con exportaci√≥n
             * @returns {Promise<Object>} Informaci√≥n del mapa base original
             */
            async switchToExportFriendlyBasemap() {
                return new Promise((resolve) => {
                    try {
                        console.log('Cambiando a mapa base compatible con exportaci√≥n...');

                        // Obtener referencia al mapa base actual
                        let currentBaseLayer = null;
                        let currentBasemapKey = null;

                        // Buscar la capa base actual
                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                // Verificar si es una capa base (no overlay)
                                if (layer.options && (
                                    layer.options.attribution?.includes('MapTiler') ||
                                    layer.options.attribution?.includes('Google') ||
                                    layer._url?.includes('maptiler') ||
                                    layer._url?.includes('google')
                                )) {
                                    currentBaseLayer = layer;
                                }
                            }
                        });

                        // El mapa base se detecta autom√°ticamente desde las capas del mapa
                        currentBasemapKey = 'auto-detected';

                        // Crear mapa base temporal sin CORS (OpenStreetMap)
                        const exportFriendlyLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors',
                            maxZoom: 19,
                            crossOrigin: null // Importante: sin restricciones CORS
                        });

                        // Remover capa base actual si existe
                        if (currentBaseLayer) {
                            this.map.removeLayer(currentBaseLayer);
                        }

                        // Agregar capa temporal
                        exportFriendlyLayer.addTo(this.map);

                        console.log('Mapa base cambiado a OpenStreetMap para exportaci√≥n');

                        // Retornar informaci√≥n para restaurar despu√©s
                        resolve({
                            originalLayer: currentBaseLayer,
                            originalKey: currentBasemapKey,
                            temporaryLayer: exportFriendlyLayer
                        });

                    } catch (error) {
                        console.error('Error cambiando mapa base:', error);
                        resolve({ originalLayer: null, originalKey: null, temporaryLayer: null });
                    }
                });
            }

            /**
             * Restaura el mapa base original despu√©s de la exportaci√≥n
             * @param {Object} originalInfo - Informaci√≥n del mapa base original
             * @returns {Promise<void>}
             */
            async restoreOriginalBasemap(originalInfo) {
                return new Promise((resolve) => {
                    try {
                        console.log('Restaurando mapa base original...');

                        if (!originalInfo) {
                            resolve();
                            return;
                        }

                        // Remover capa temporal
                        if (originalInfo.temporaryLayer) {
                            this.map.removeLayer(originalInfo.temporaryLayer);
                        }

                        // Restaurar capa original
                        if (originalInfo.originalLayer) {
                            originalInfo.originalLayer.addTo(this.map);
                        }

                        // El mapa base se restaura autom√°ticamente desde las capas guardadas

                        console.log('Mapa base original restaurado');
                        resolve();

                    } catch (error) {
                        console.error('Error restaurando mapa base:', error);
                        resolve(); // Continuar aunque haya error
                    }
                });
            }

            /**
             * Captura usando screenshot del DOM con configuraci√≥n optimizada
             * @returns {Promise<HTMLCanvasElement>}
             */
            async captureWithStaticImage() {
                return new Promise(async (resolve, reject) => {
                    try {
                        console.log('Intentando captura optimizada del DOM...');

                        const mapContainer = this.map.getContainer();
                        const size = this.map.getSize();

                        // Ocultar temporalmente controles que no queremos en la exportaci√≥n
                        const controlsToHide = mapContainer.querySelectorAll('.leaflet-control-zoom, .leaflet-control-layers, .leaflet-control-attribution');
                        const originalDisplays = [];

                        controlsToHide.forEach((control, index) => {
                            originalDisplays[index] = control.style.display;
                            control.style.display = 'none';
                        });

                        // Esperar un momento para que se apliquen los cambios
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Intentar captura con html2canvas si est√° disponible
                        if (typeof html2canvas !== 'undefined') {
                            try {
                                const canvas = await html2canvas(mapContainer, {
                                    allowTaint: true,
                                    useCORS: false, // Desactivar CORS para evitar problemas
                                    scale: 1,
                                    width: size.x,
                                    height: size.y,
                                    backgroundColor: '#ffffff',
                                    logging: false,
                                    removeContainer: false,
                                    foreignObjectRendering: false
                                });

                                // Restaurar controles
                                controlsToHide.forEach((control, index) => {
                                    control.style.display = originalDisplays[index];
                                });

                                if (canvas && canvas.width > 0 && canvas.height > 0) {
                                    // Procesar el canvas para reemplazar √°reas grises
                                    this.fixGrayAreas(canvas);
                                    console.log('Captura DOM exitosa con correcci√≥n de √°reas grises');
                                    resolve(canvas);
                                    return;
                                }
                            } catch (html2canvasError) {
                                console.warn('html2canvas fall√≥:', html2canvasError);
                            }
                        }

                        // Restaurar controles si html2canvas fall√≥
                        controlsToHide.forEach((control, index) => {
                            control.style.display = originalDisplays[index];
                        });

                        // Si html2canvas falla, crear canvas con informaci√≥n b√°sica
                        reject(new Error('Captura DOM no disponible'));

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            /**
             * Corrige las √°reas grises en el canvas reemplaz√°ndolas con un patr√≥n de mapa
             * @param {HTMLCanvasElement} canvas 
             */
            fixGrayAreas(canvas) {
                try {
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;

                    console.log('Procesando √°reas grises en el canvas...');

                    // Detectar y reemplazar p√≠xeles grises
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const a = data[i + 3];

                        // Detectar grises (valores similares en RGB) y p√≠xeles transparentes
                        const isGray = Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && Math.abs(r - b) < 15 &&
                            r > 80 && r < 200 && a > 0;

                        const isTransparent = a < 50;

                        if (isGray || isTransparent) {
                            // Calcular coordenadas del p√≠xel
                            const pixelIndex = i / 4;
                            const x = pixelIndex % canvas.width;
                            const y = Math.floor(pixelIndex / canvas.width);

                            // Crear un patr√≥n que simule un mapa base
                            const pattern1 = Math.sin(x * 0.02) * Math.cos(y * 0.02);
                            const pattern2 = Math.sin(x * 0.005 + y * 0.005);

                            // Colores base tipo mapa (beige/crema)
                            const baseR = 245;
                            const baseG = 245;
                            const baseB = 240;

                            // Aplicar variaci√≥n sutil
                            data[i] = Math.max(220, Math.min(255, baseR + pattern1 * 10 + pattern2 * 5));     // R
                            data[i + 1] = Math.max(220, Math.min(255, baseG + pattern1 * 8 + pattern2 * 4)); // G
                            data[i + 2] = Math.max(215, Math.min(250, baseB + pattern1 * 6 + pattern2 * 3)); // B
                            data[i + 3] = 255; // Alpha completo
                        }
                    }

                    // Aplicar los cambios
                    ctx.putImageData(imageData, 0, 0);

                    // Agregar algunas l√≠neas sutiles para simular caracter√≠sticas geogr√°ficas
                    this.addMapFeatures(ctx, canvas.width, canvas.height);

                    console.log('√Åreas grises corregidas exitosamente');

                } catch (error) {
                    console.warn('Error corrigiendo √°reas grises:', error);
                }
            }

            /**
             * Agrega caracter√≠sticas sutiles al mapa para simular geograf√≠a
             * @param {CanvasRenderingContext2D} ctx 
             * @param {number} width 
             * @param {number} height 
             */
            addMapFeatures(ctx, width, height) {
                try {
                    // Guardar estado del contexto
                    ctx.save();

                    // L√≠neas sutiles que simulan r√≠os o carreteras
                    ctx.strokeStyle = 'rgba(200, 200, 190, 0.3)';
                    ctx.lineWidth = 1;

                    // Algunas l√≠neas curvas aleatorias
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * width;
                        const startY = Math.random() * height;

                        ctx.moveTo(startX, startY);

                        for (let j = 0; j < 3; j++) {
                            const cpX = startX + (Math.random() - 0.5) * width * 0.5;
                            const cpY = startY + (Math.random() - 0.5) * height * 0.5;
                            const endX = startX + (Math.random() - 0.5) * width * 0.3;
                            const endY = startY + (Math.random() - 0.5) * height * 0.3;

                            ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                        }

                        ctx.stroke();
                    }

                    // Restaurar estado del contexto
                    ctx.restore();

                } catch (error) {
                    console.warn('Error agregando caracter√≠sticas del mapa:', error);
                }
            }

            /**
             * Captura simple usando leaflet-image sin filtros complejos
             * @returns {Promise<HTMLCanvasElement>}
             */
            async performSimpleCapture() {
                return new Promise((resolve, reject) => {
                    try {
                        console.log('Captura simple con leaflet-image...');

                        // Configuraci√≥n m√≠nima para leaflet-image
                        const options = {};

                        leafletImage(this.map, (err, canvas) => {
                            if (err) {
                                console.error('Error en leaflet-image simple:', err);
                                reject(new Error('Error en captura simple: ' + err.message));
                                return;
                            }

                            if (!canvas || canvas.width === 0 || canvas.height === 0) {
                                reject(new Error('Canvas simple inv√°lido'));
                                return;
                            }

                            console.log(`Captura simple completada: ${canvas.width}x${canvas.height}`);
                            resolve(canvas);
                        }, options);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            /**
             * Crea un canvas b√°sico con informaci√≥n del mapa cuando todo falla
             * @returns {Promise<HTMLCanvasElement>}
             */
            async createBasicMapCanvas() {
                return new Promise((resolve) => {
                    try {
                        const size = this.map.getSize();
                        const canvas = document.createElement('canvas');
                        canvas.width = size.x;
                        canvas.height = size.y;
                        const ctx = canvas.getContext('2d');

                        // Fondo blanco
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Dibujar informaci√≥n b√°sica del mapa
                        ctx.fillStyle = '#333333';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';

                        const center = this.map.getCenter();
                        const zoom = this.map.getZoom();

                        ctx.fillText('Mapa SNIEn', canvas.width / 2, canvas.height / 2 - 40);
                        ctx.fillText(`Centro: ${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`, canvas.width / 2, canvas.height / 2);
                        ctx.fillText(`Zoom: ${zoom}`, canvas.width / 2, canvas.height / 2 + 40);
                        ctx.fillText('(Vista previa no disponible)', canvas.width / 2, canvas.height / 2 + 80);

                        // Dibujar borde
                        ctx.strokeStyle = '#cccccc';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

                        console.log('Canvas b√°sico creado como √∫ltimo recurso');
                        resolve(canvas);

                    } catch (error) {
                        console.error('Error creando canvas b√°sico:', error);
                        // Crear canvas m√≠nimo
                        const canvas = document.createElement('canvas');
                        canvas.width = 800;
                        canvas.height = 600;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        resolve(canvas);
                    }
                });
            }



            /**
             * Agrega overlays y marcadores al canvas est√°tico
             * @param {HTMLCanvasElement} canvas 
             * @param {CanvasRenderingContext2D} ctx 
             * @returns {Promise<void>}
             */
            async addOverlaysToStaticCanvas(canvas, ctx) {
                return new Promise((resolve) => {
                    try {
                        // Buscar marcadores y overlays en el mapa
                        const markers = [];

                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.Marker) {
                                const pos = this.map.latLngToContainerPoint(layer.getLatLng());
                                markers.push({
                                    x: pos.x,
                                    y: pos.y,
                                    layer: layer
                                });
                            }
                        });

                        // Dibujar marcadores simples
                        markers.forEach(marker => {
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(marker.x, marker.y, 8, 0, 2 * Math.PI);
                            ctx.fill();

                            // Borde blanco
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        });

                        console.log(`Agregados ${markers.length} marcadores al canvas est√°tico`);
                        resolve();

                    } catch (error) {
                        console.warn('Error agregando overlays al canvas est√°tico:', error);
                        resolve();
                    }
                });
            }



            /**
             * M√©todo de captura legacy usando leaflet-image
             * @returns {Promise<HTMLCanvasElement>}
             */
            async performLegacyCapture() {
                return new Promise((resolve, reject) => {
                    try {
                        console.log('Usando leaflet-image para captura...');

                        // Forzar un repaint antes de la captura
                        this.map.getContainer().style.transform = 'translateZ(0)';

                        // Usar requestAnimationFrame para asegurar que el render est√© completo
                        requestAnimationFrame(() => {
                            // Configurar opciones para leaflet-image
                            const options = {
                                filter: (node) => {
                                    if (node.classList) {
                                        // Excluir controles
                                        if (node.classList.contains('leaflet-control-zoom') ||
                                            node.classList.contains('leaflet-control-layers') ||
                                            node.classList.contains('leaflet-control-attribution')) {
                                            return false;
                                        }
                                    }
                                    return true;
                                }
                            };

                            // Usar leaflet-image para capturar el mapa
                            leafletImage(this.map, (err, canvas) => {
                                // Restaurar el estilo del contenedor
                                this.map.getContainer().style.transform = '';

                                if (err) {
                                    console.error('Error en leaflet-image:', err);
                                    reject(new Error('Error capturando el mapa: ' + err.message));
                                    return;
                                }

                                // Verificar que el canvas sea v√°lido
                                if (!canvas || canvas.width === 0 || canvas.height === 0) {
                                    reject(new Error('Canvas capturado inv√°lido'));
                                    return;
                                }

                                console.log(`Captura legacy completada: ${canvas.width}x${canvas.height}`);
                                resolve(canvas);
                            }, options);
                        });
                    } catch (error) {
                        console.error('Error en performLegacyCapture:', error);
                        reject(new Error('Error en leaflet-image: ' + error.message));
                    }
                });
            }

            /**
             * Fuerza la recarga de tiles en el √°rea visible del mapa
             * @returns {Promise<void>}
             */
            async refreshVisibleTiles() {
                return new Promise((resolve) => {
                    let layersToRefresh = 0;
                    let layersRefreshed = 0;

                    const onLayerRefreshed = () => {
                        layersRefreshed++;
                        if (layersRefreshed >= layersToRefresh) {
                            resolve();
                        }
                    };

                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.TileLayer) {
                            layersToRefresh++;

                            // Forzar recarga de la capa
                            layer.once('load', onLayerRefreshed);
                            layer.redraw();
                        }
                    });

                    // Si no hay capas para refrescar, resolver inmediatamente
                    if (layersToRefresh === 0) {
                        resolve();
                    }
                });
            }

            /**
             * Valida que el mapa est√© en un estado v√°lido para captura
             * @returns {boolean} True si el mapa est√° listo para capturar
             */
            validateMapState() {
                if (!this.map) {
                    throw new Error('Mapa no inicializado');
                }

                const container = this.map.getContainer();
                if (!container || container.offsetWidth === 0 || container.offsetHeight === 0) {
                    throw new Error('Contenedor del mapa no visible o sin dimensiones');
                }

                const bounds = this.map.getBounds();
                if (!bounds || !bounds.isValid()) {
                    throw new Error('L√≠mites del mapa inv√°lidos');
                }

                return true;
            }

            /**
             * Obtiene informaci√≥n detallada sobre el estado de carga de tiles
             * @returns {Object} Informaci√≥n de estado de tiles
             */
            getTileLoadingStatus() {
                const status = {
                    totalLayers: 0,
                    loadedLayers: 0,
                    totalTiles: 0,
                    loadedTiles: 0,
                    failedTiles: 0,
                    totalMarkers: 0,
                    loadedMarkers: 0,
                    failedMarkers: 0
                };

                this.map.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer) {
                        status.totalLayers++;

                        const container = layer.getContainer();
                        if (container) {
                            const tiles = container.querySelectorAll('img');
                            tiles.forEach((tile) => {
                                status.totalTiles++;
                                if (tile.complete && tile.naturalWidth > 0) {
                                    status.loadedTiles++;
                                } else if (tile.complete && tile.naturalWidth === 0) {
                                    status.failedTiles++;
                                }
                            });

                            if (tiles.length > 0 && status.loadedTiles === tiles.length) {
                                status.loadedLayers++;
                            }
                        }
                    }

                    // Verificar estado de marcadores
                    if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                        status.totalMarkers++;

                        if (layer._icon) {
                            const img = layer._icon.querySelector('img');
                            if (img) {
                                if (img.complete && img.naturalWidth > 0) {
                                    status.loadedMarkers++;
                                } else if (img.complete && img.naturalWidth === 0) {
                                    status.failedMarkers++;
                                }
                            } else {
                                // Marcador sin imagen (ej: CircleMarker o icono CSS)
                                status.loadedMarkers++;
                            }
                        } else {
                            // Marcador sin icono visible
                            status.loadedMarkers++;
                        }
                    }
                });

                return status;
            }

            /**
             * Prepara los elementos de la interfaz para la captura
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Object} Estado original de la UI para restaurar despu√©s
             */
            async prepareUIForCapture(config) {
                const uiState = {
                    hiddenElements: [],
                    modifiedElements: []
                };

                // Ocultar controles de zoom si no se requieren en la exportaci√≥n
                const zoomControls = this.map.getContainer().querySelectorAll('.leaflet-control-zoom');
                zoomControls.forEach(control => {
                    if (control.style.display !== 'none') {
                        uiState.hiddenElements.push({
                            element: control,
                            originalDisplay: control.style.display
                        });
                        control.style.display = 'none';
                    }
                });

                // Ocultar controles de capas si no se requieren
                const layerControls = this.map.getContainer().querySelectorAll('.leaflet-control-layers');
                layerControls.forEach(control => {
                    if (control.style.display !== 'none') {
                        uiState.hiddenElements.push({
                            element: control,
                            originalDisplay: control.style.display
                        });
                        control.style.display = 'none';
                    }
                });

                // Mejorar visibilidad de marcadores para la captura
                await this.enhanceMarkersForCapture(uiState);

                return uiState;
            }

            /**
             * Mejora la visibilidad de los marcadores para la captura
             * @param {Object} uiState - Estado de la UI para tracking de cambios
             */
            async enhanceMarkersForCapture(uiState) {
                return new Promise((resolve) => {
                    let markersProcessed = 0;
                    let totalMarkers = 0;

                    // Contar total de marcadores
                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                            totalMarkers++;
                        }
                    });

                    if (totalMarkers === 0) {
                        resolve();
                        return;
                    }

                    // Procesar cada marcador
                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                            // Asegurar que el marcador est√© visible
                            if (layer._icon) {
                                const icon = layer._icon;

                                // Guardar estado original
                                const originalZIndex = icon.style.zIndex;
                                const originalOpacity = icon.style.opacity;

                                uiState.modifiedElements.push({
                                    element: icon,
                                    originalZIndex: originalZIndex,
                                    originalOpacity: originalOpacity
                                });

                                // Mejorar visibilidad para captura
                                icon.style.zIndex = '1000';
                                icon.style.opacity = '1';

                                // Forzar repaint del marcador
                                icon.style.transform = icon.style.transform;
                            }

                            markersProcessed++;
                            if (markersProcessed >= totalMarkers) {
                                // Dar tiempo para que se apliquen los cambios
                                setTimeout(resolve, 100);
                            }
                        }
                    });
                });
            }

            /**
             * Asegura que todos los marcadores est√©n listos para la captura
             * @returns {Promise<void>}
             */
            async ensureMarkersReady() {
                return new Promise((resolve) => {
                    let markersReady = 0;
                    let totalMarkers = 0;

                    // Contar marcadores
                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                            totalMarkers++;
                        }
                    });

                    if (totalMarkers === 0) {
                        console.log('No hay marcadores en el mapa');
                        resolve();
                        return;
                    }

                    console.log(`Verificando ${totalMarkers} marcadores...`);

                    // Verificar cada marcador
                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                            // Verificar si el marcador tiene icono y est√° en el DOM
                            if (layer._icon && layer._icon.parentNode) {
                                // Verificar si el icono est√° completamente cargado
                                const icon = layer._icon;
                                const img = icon.querySelector('img');

                                if (img) {
                                    if (img.complete && img.naturalWidth > 0) {
                                        markersReady++;
                                    } else {
                                        // Esperar a que la imagen se cargue
                                        img.onload = () => {
                                            markersReady++;
                                            if (markersReady >= totalMarkers) {
                                                console.log(`Todos los ${totalMarkers} marcadores est√°n listos`);
                                                resolve();
                                            }
                                        };
                                        img.onerror = () => {
                                            console.warn('Error cargando icono de marcador');
                                            markersReady++;
                                            if (markersReady >= totalMarkers) {
                                                resolve();
                                            }
                                        };
                                    }
                                } else {
                                    // Marcador sin imagen (ej: CircleMarker)
                                    markersReady++;
                                }
                            } else {
                                console.warn('Marcador sin icono o no en DOM');
                                markersReady++;
                            }

                            // Verificar si ya est√°n todos listos
                            if (markersReady >= totalMarkers) {
                                console.log(`Todos los ${totalMarkers} marcadores est√°n listos`);
                                resolve();
                            }
                        }
                    });

                    // Timeout de seguridad
                    setTimeout(() => {
                        if (markersReady < totalMarkers) {
                            console.warn(`Timeout: solo ${markersReady}/${totalMarkers} marcadores listos`);
                        }
                        resolve();
                    }, 3000);
                });
            }

            /**
             * Restaura el estado original de la interfaz despu√©s de la captura
             * @param {Object} uiState - Estado original de la UI
             */
            async restoreUIState(uiState) {
                // Restaurar elementos ocultos
                uiState.hiddenElements.forEach(item => {
                    item.element.style.display = item.originalDisplay;
                });

                // Restaurar elementos modificados
                uiState.modifiedElements.forEach(item => {
                    if (item.originalZIndex !== undefined) {
                        item.element.style.zIndex = item.originalZIndex;
                    }
                    if (item.originalOpacity !== undefined) {
                        item.element.style.opacity = item.originalOpacity;
                    }
                });

                // Dar tiempo para que se restauren los cambios
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            /**
             * Obtiene informaci√≥n detallada sobre marcadores visibles
             * @returns {Object} Informaci√≥n de marcadores
             */
            getMarkersInfo() {
                const markersInfo = {
                    total: 0,
                    visible: 0,
                    withIcons: 0,
                    inBounds: 0,
                    details: []
                };

                const mapBounds = this.map.getBounds();

                this.map.eachLayer((layer) => {
                    if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
                        markersInfo.total++;

                        const latLng = layer.getLatLng();
                        const isInBounds = mapBounds.contains(latLng);
                        const hasIcon = layer._icon && layer._icon.parentNode;
                        const isVisible = hasIcon && layer._icon.style.display !== 'none';

                        if (isInBounds) markersInfo.inBounds++;
                        if (hasIcon) markersInfo.withIcons++;
                        if (isVisible) markersInfo.visible++;

                        markersInfo.details.push({
                            position: latLng,
                            inBounds: isInBounds,
                            hasIcon: hasIcon,
                            visible: isVisible,
                            type: layer instanceof L.Marker ? 'marker' : 'circle'
                        });
                    }
                });

                return markersInfo;
            }

            /**
             * Obtiene metadatos del mapa actual
             * @returns {Object} Metadatos del mapa
             */
            getMapMetadata() {
                const center = this.map.getCenter();
                const bounds = this.map.getBounds();

                // Obtener informaci√≥n detallada de la capa base actual
                const baseLayerInfo = this.getBaseLayerInfo();

                // Los selectores de instrumentos y planes se han eliminado de la interfaz
                // El mapa base se detecta autom√°ticamente desde las capas activas
                const selectedInstrumentText = 'Configurado desde control de capas';
                const selectedPlanText = 'Configurado desde control de capas';
                const selectedBasemapText = baseLayerInfo.name || 'Mapa base activo';

                // Obtener informaci√≥n detallada de marcadores
                const markersInfo = this.getMarkersInfo();

                // Obtener fecha de √∫ltima actualizaci√≥n de datos
                const lastUpdatedElement = document.getElementById('last-updated');
                const lastUpdated = lastUpdatedElement?.textContent || 'No disponible';

                return {
                    timestamp: new Date(),
                    baseLayer: baseLayerInfo.name,
                    baseLayerAttribution: baseLayerInfo.attribution,
                    selectedInstrument: selectedInstrumentText,
                    selectedInstrumentValue: 'control-capas',
                    selectedPlan: selectedPlanText,
                    selectedPlanValue: 'control-capas',
                    selectedBasemap: selectedBasemapText,
                    selectedBasemapValue: 'control-capas',
                    zoomLevel: this.map.getZoom(),
                    center: {
                        lat: Math.round(center.lat * 100000) / 100000, // 5 decimales
                        lng: Math.round(center.lng * 100000) / 100000
                    },
                    bounds: {
                        north: Math.round(bounds.getNorth() * 100000) / 100000,
                        south: Math.round(bounds.getSouth() * 100000) / 100000,
                        east: Math.round(bounds.getEast() * 100000) / 100000,
                        west: Math.round(bounds.getWest() * 100000) / 100000
                    },
                    markersCount: markersInfo.total,
                    markersVisible: markersInfo.visible,
                    markersInBounds: markersInfo.inBounds,
                    lastDataUpdate: lastUpdated,
                    dataSource: 'Hoja de c√°lculo institucional publicada (Google Sheets)',
                    system: 'Sistema Nacional de Informaci√≥n Energ√©tica (SNIEn)',
                    organization: 'Secretar√≠a de Energ√≠a (SENER)'
                };
            }

            /**
             * Obtiene informaci√≥n detallada de la capa base actual
             * @returns {Object} Informaci√≥n de la capa base y atribuciones
             */
            getBaseLayerInfo() {
                let layerName = 'Desconocido';
                let attribution = '';

                this.map.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer && layer.options) {
                        // Detectar capas de MapTiler
                        if (layer.options.style) {
                            const styleName = layer.options.style;
                            layerName = `MapTiler ${styleName}`;
                            attribution = '¬© MapTiler ¬© OpenStreetMap contributors';
                        } else if (layer._url && layer._url.includes('maptiler')) {
                            layerName = 'MapTiler';
                            attribution = '¬© MapTiler ¬© OpenStreetMap contributors';
                        } else if (layer._url && layer._url.includes('google')) {
                            layerName = 'Google Satellite';
                            attribution = '¬© Google ¬© Satellite imagery';
                        } else if (layer._url) {
                            layerName = 'Tile Layer';
                            attribution = layer.options.attribution || '';
                        }

                        // Si la capa tiene atribuci√≥n espec√≠fica, usarla
                        if (layer.options.attribution) {
                            attribution = layer.options.attribution;
                        }
                    }
                });

                // Detectar el mapa base autom√°ticamente desde las capas activas
                // Ya no usamos selector, se detecta desde el control de capas de Leaflet

                return {
                    name: layerName,
                    attribution: attribution
                };
            }
        }

        /**
         * Generador de archivos PDF
         */
        class PDFGenerator {
            constructor() {
                this.jsPDF = window.jspdf?.jsPDF || window.jsPDF;
                if (!this.jsPDF) {
                    throw new Error('jsPDF no est√° disponible');
                }

                // Definir tama√±os de p√°gina est√°ndar en mm
                this.pageSizes = {
                    'A4': { width: 210, height: 297 },
                    'A3': { width: 297, height: 420 },
                    'Letter': { width: 216, height: 279 }
                };
            }

            /**
             * Crea un canvas limpio copiando los datos p√≠xel por p√≠xel para evitar problemas de CORS
             * @param {HTMLCanvasElement} sourceCanvas - Canvas fuente que puede estar "tainted"
             * @returns {HTMLCanvasElement} Canvas limpio sin restricciones CORS
             */
            createCleanCanvas(sourceCanvas) {
                try {
                    console.log('Creando canvas limpio para evitar problemas CORS...');

                    // Crear nuevo canvas con las mismas dimensiones
                    const cleanCanvas = document.createElement('canvas');
                    cleanCanvas.width = sourceCanvas.width;
                    cleanCanvas.height = sourceCanvas.height;

                    const cleanCtx = cleanCanvas.getContext('2d');
                    const sourceCtx = sourceCanvas.getContext('2d');

                    try {
                        // Intentar copiar usando getImageData (m√©todo m√°s seguro)
                        const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                        cleanCtx.putImageData(imageData, 0, 0);

                        console.log('Canvas limpio creado usando getImageData');
                        return cleanCanvas;

                    } catch (getImageDataError) {
                        console.warn('getImageData fall√≥, intentando drawImage:', getImageDataError);

                        try {
                            // Fallback: intentar drawImage
                            cleanCtx.drawImage(sourceCanvas, 0, 0);

                            console.log('Canvas limpio creado usando drawImage');
                            return cleanCanvas;

                        } catch (drawImageError) {
                            console.warn('drawImage tambi√©n fall√≥:', drawImageError);

                            // √öltimo recurso: crear canvas b√°sico con informaci√≥n
                            cleanCtx.fillStyle = '#ffffff';
                            cleanCtx.fillRect(0, 0, cleanCanvas.width, cleanCanvas.height);

                            cleanCtx.fillStyle = '#333333';
                            cleanCtx.font = '20px Arial';
                            cleanCtx.textAlign = 'center';
                            cleanCtx.fillText('Mapa SNIEn', cleanCanvas.width / 2, cleanCanvas.height / 2);
                            cleanCtx.fillText('(Exportaci√≥n de emergencia)', cleanCanvas.width / 2, cleanCanvas.height / 2 + 30);

                            console.log('Canvas b√°sico creado como √∫ltimo recurso');
                            return cleanCanvas;
                        }
                    }

                } catch (error) {
                    console.error('Error creando canvas limpio:', error);

                    // Canvas de emergencia
                    const emergencyCanvas = document.createElement('canvas');
                    emergencyCanvas.width = 800;
                    emergencyCanvas.height = 600;
                    const emergencyCtx = emergencyCanvas.getContext('2d');

                    emergencyCtx.fillStyle = '#ffffff';
                    emergencyCtx.fillRect(0, 0, 800, 600);

                    emergencyCtx.fillStyle = '#333333';
                    emergencyCtx.font = '24px Arial';
                    emergencyCtx.textAlign = 'center';
                    emergencyCtx.fillText('Error en exportaci√≥n', 400, 280);
                    emergencyCtx.fillText('Mapa SNIEn', 400, 320);

                    return emergencyCanvas;
                }
            }

            /**
             * Genera un PDF a partir de un canvas
             * @param {HTMLCanvasElement} canvas - Canvas con la imagen del mapa
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @param {Object} metadata - Metadatos del mapa
             * @returns {Blob} Archivo PDF generado
             */
            async generatePDF(canvas, config, metadata) {
                try {
                    console.log('Generando PDF con configuraci√≥n:', config);

                    // Determinar formato y orientaci√≥n del PDF
                    const pdfConfig = this.determinePDFConfiguration(config);
                    console.log('Configuraci√≥n PDF determinada:', pdfConfig);

                    // Crear documento PDF
                    const pdf = new this.jsPDF({
                        orientation: pdfConfig.orientation,
                        unit: 'mm',
                        format: pdfConfig.format
                    });

                    // A√±adir metadatos del documento
                    this.addDocumentMetadata(pdf, config, metadata);

                    // Crear canvas limpio para evitar problemas de CORS
                    const cleanCanvas = this.createCleanCanvas(canvas);

                    // Convertir canvas limpio a imagen de alta calidad
                    const imgData = cleanCanvas.toDataURL('image/png', 1.0);
                    console.log('Imagen convertida a base64, tama√±o:', imgData.length, 'caracteres');

                    // Calcular dimensiones y posicionamiento
                    const layout = this.calculateLayout(pdf, canvas, config);
                    console.log('Layout calculado:', layout);

                    // A√±adir imagen principal al PDF
                    pdf.addImage(
                        imgData,
                        'PNG',
                        layout.imageX,
                        layout.imageY,
                        layout.imageWidth,
                        layout.imageHeight,
                        undefined,
                        'FAST' // Usar compresi√≥n r√°pida para mejor rendimiento
                    );

                    // A√±adir informaci√≥n contextual si est√° habilitada
                    if (this.shouldIncludeContextualInfo(config)) {
                        this.addContextualInfo(pdf, config, metadata, layout);
                    }

                    // Generar y retornar el blob del PDF
                    const pdfBlob = pdf.output('blob');
                    console.log('PDF generado exitosamente, tama√±o:', pdfBlob.size, 'bytes');

                    return pdfBlob;
                } catch (error) {
                    console.error('Error detallado en generatePDF:', error);
                    throw new Error('Error generando PDF: ' + error.message);
                }
            }

            /**
             * Determina la configuraci√≥n del PDF basada en el tama√±o especificado
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Object} Configuraci√≥n del PDF (formato y orientaci√≥n)
             */
            determinePDFConfiguration(config) {
                const preset = config.size.preset;

                // Para tama√±os personalizados
                if (preset === 'custom') {
                    const width = config.size.width * 0.264583; // Convertir p√≠xeles a mm (96 DPI)
                    const height = config.size.height * 0.264583;

                    return {
                        format: [width, height],
                        orientation: width > height ? 'landscape' : 'portrait'
                    };
                }

                // Para tama√±os est√°ndar
                if (this.pageSizes[preset]) {
                    const size = this.pageSizes[preset];
                    return {
                        format: [size.width, size.height],
                        orientation: 'portrait' // Por defecto portrait, se puede cambiar seg√∫n necesidades
                    };
                }

                // Fallback a A4 si no se reconoce el tama√±o
                console.warn('Tama√±o de p√°gina no reconocido:', preset, '- usando A4 por defecto');
                return {
                    format: 'a4',
                    orientation: 'portrait'
                };
            }

            /**
             * A√±ade metadatos al documento PDF
             * @param {Object} pdf - Instancia de jsPDF
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @param {Object} metadata - Metadatos del mapa
             */
            addDocumentMetadata(pdf, config, metadata) {
                const currentDate = new Date();

                pdf.setProperties({
                    title: config.metadata.title || 'Mapa SNIEn',
                    subject: config.metadata.subject || 'Mapa del Sistema Nacional de Informaci√≥n Energ√©tica',
                    author: config.metadata.author || 'SENER',
                    creator: config.metadata.creator || 'SNIEn - SENER',
                    keywords: 'SNIEn, SENER, Mapa, Energ√≠a, M√©xico',
                    creationDate: currentDate,
                    modDate: currentDate
                });

                console.log('Metadatos del documento a√±adidos');
            }

            /**
             * Calcula el layout y dimensiones para la imagen en el PDF
             * @param {Object} pdf - Instancia de jsPDF
             * @param {HTMLCanvasElement} canvas - Canvas con la imagen
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Object} Informaci√≥n del layout
             */
            calculateLayout(pdf, canvas, config) {
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15; // Margen en mm

                // √Årea disponible para la imagen
                const availableWidth = pageWidth - (margin * 2);
                const availableHeight = pageHeight - (margin * 2);

                // Reservar espacio para informaci√≥n contextual si es necesario
                const contextualInfoHeight = this.shouldIncludeContextualInfo(config) ? 25 : 0;
                const imageAreaHeight = availableHeight - contextualInfoHeight;

                // Calcular dimensiones manteniendo proporci√≥n
                const canvasRatio = canvas.width / canvas.height;
                const availableRatio = availableWidth / imageAreaHeight;

                let imageWidth, imageHeight;

                if (canvasRatio > availableRatio) {
                    // La imagen es m√°s ancha, ajustar por ancho
                    imageWidth = availableWidth;
                    imageHeight = availableWidth / canvasRatio;
                } else {
                    // La imagen es m√°s alta, ajustar por alto
                    imageHeight = imageAreaHeight;
                    imageWidth = imageAreaHeight * canvasRatio;
                }

                // Centrar la imagen
                const imageX = margin + (availableWidth - imageWidth) / 2;
                const imageY = margin;

                return {
                    pageWidth,
                    pageHeight,
                    margin,
                    imageX,
                    imageY,
                    imageWidth,
                    imageHeight,
                    availableWidth,
                    contextualInfoHeight,
                    contextualInfoY: imageY + imageHeight + 10
                };
            }

            /**
             * Determina si se debe incluir informaci√≥n contextual
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {boolean} True si se debe incluir informaci√≥n contextual
             */
            shouldIncludeContextualInfo(config) {
                return config.elements.includeTitle ||
                    config.elements.includeTimestamp ||
                    config.elements.includeAttribution ||
                    config.elements.includeScale;
            }

            /**
             * A√±ade informaci√≥n contextual al PDF
             * @param {Object} pdf - Instancia de jsPDF
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @param {Object} metadata - Metadatos del mapa
             * @param {Object} layout - Informaci√≥n del layout
             */
            addContextualInfo(pdf, config, metadata, layout) {
                let currentY = layout.contextualInfoY;
                const lineHeight = 4;
                const sectionSpacing = 2;

                // Configurar estilo del texto principal
                pdf.setFontSize(10);
                pdf.setTextColor(60, 60, 60);

                // T√≠tulo del mapa
                if (config.elements.includeTitle && config.metadata.title) {
                    pdf.setFontSize(12);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(config.metadata.title, layout.margin, currentY);
                    currentY += lineHeight + sectionSpacing;
                    pdf.setFont(undefined, 'normal');
                    pdf.setFontSize(10);
                }

                // Informaci√≥n de generaci√≥n y fecha
                if (config.elements.includeTimestamp) {
                    const timestamp = metadata.timestamp ?
                        metadata.timestamp.toLocaleString('es-MX', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            timeZoneName: 'short'
                        }) :
                        new Date().toLocaleString('es-MX');

                    pdf.text(`Fecha de generaci√≥n: ${timestamp}`, layout.margin, currentY);
                    currentY += lineHeight;

                    // Informaci√≥n de √∫ltima actualizaci√≥n de datos
                    if (metadata.lastDataUpdate && metadata.lastDataUpdate !== 'No disponible') {
                        pdf.text(`√öltima actualizaci√≥n de datos: ${metadata.lastDataUpdate}`, layout.margin, currentY);
                        currentY += lineHeight;
                    }

                    currentY += sectionSpacing;
                }

                // Informaci√≥n del mapa base y configuraci√≥n
                if (metadata.baseLayer) {
                    pdf.text(`Mapa base: ${metadata.baseLayer}`, layout.margin, currentY);
                    currentY += lineHeight;

                    // Nivel de zoom y coordenadas del centro
                    pdf.text(`Nivel de zoom: ${metadata.zoomLevel}`, layout.margin, currentY);
                    currentY += lineHeight;

                    pdf.text(`Centro: ${metadata.center.lat}¬∞, ${metadata.center.lng}¬∞`, layout.margin, currentY);
                    currentY += lineHeight + sectionSpacing;
                }

                // Informaci√≥n de selecciones activas
                if (metadata.selectedInstrument && metadata.selectedInstrument !== 'Ninguno seleccionado') {
                    pdf.text(`Instrumento seleccionado:`, layout.margin, currentY);
                    currentY += lineHeight;

                    // Usar texto m√°s peque√±o para el nombre completo del instrumento
                    pdf.setFontSize(9);
                    const instrumentLines = pdf.splitTextToSize(metadata.selectedInstrument, layout.availableWidth - 10);
                    pdf.text(instrumentLines, layout.margin + 5, currentY);
                    currentY += lineHeight * instrumentLines.length;
                    pdf.setFontSize(10);
                }

                if (metadata.selectedPlan && metadata.selectedPlan !== 'Ninguno seleccionado') {
                    pdf.text(`Plan complementario seleccionado:`, layout.margin, currentY);
                    currentY += lineHeight;

                    // Usar texto m√°s peque√±o para el nombre completo del plan
                    pdf.setFontSize(9);
                    const planLines = pdf.splitTextToSize(metadata.selectedPlan, layout.availableWidth - 10);
                    pdf.text(planLines, layout.margin + 5, currentY);
                    currentY += lineHeight * planLines.length;
                    pdf.setFontSize(10);
                    currentY += sectionSpacing;
                }

                // Informaci√≥n de marcadores si hay elementos visibles
                if (metadata.markersVisible > 0) {
                    pdf.text(`Elementos visibles en el mapa: ${metadata.markersVisible}`, layout.margin, currentY);
                    currentY += lineHeight + sectionSpacing;
                }

                // Atribuciones y fuentes de datos
                if (config.elements.includeAttribution) {
                    currentY += sectionSpacing;
                    pdf.setFontSize(8);
                    pdf.setTextColor(100, 100, 100);

                    // Fuente principal
                    pdf.text(`Fuente de datos: ${metadata.dataSource}`, layout.margin, currentY);
                    currentY += lineHeight - 1;

                    // Sistema y organizaci√≥n
                    pdf.text(`Sistema: ${metadata.system}`, layout.margin, currentY);
                    currentY += lineHeight - 1;

                    pdf.text(`Organizaci√≥n: ${metadata.organization}`, layout.margin, currentY);
                    currentY += lineHeight - 1;

                    // Atribuci√≥n cartogr√°fica
                    if (metadata.baseLayerAttribution) {
                        pdf.text(`Datos cartogr√°ficos: ${metadata.baseLayerAttribution}`, layout.margin, currentY);
                        currentY += lineHeight - 1;
                    }

                    // Informaci√≥n adicional
                    pdf.text('Generado con tecnolog√≠a web abierta y est√°ndares de datos abiertos', layout.margin, currentY);
                }

                console.log('Informaci√≥n contextual completa a√±adida al PDF');
            }
        }

        /**
         * Procesador de im√°genes PNG
         */
        class PNGProcessor {
            constructor() {
                // Configuraciones predefinidas para diferentes calidades
                this.qualityPresets = {
                    150: { compression: 0.8, smoothing: 'medium' },
                    300: { compression: 0.9, smoothing: 'high' },
                    600: { compression: 1.0, smoothing: 'high' }
                };
            }

            /**
             * Crea un canvas limpio copiando los datos p√≠xel por p√≠xel para evitar problemas de CORS
             * @param {HTMLCanvasElement} sourceCanvas - Canvas fuente que puede estar "tainted"
             * @returns {HTMLCanvasElement} Canvas limpio sin restricciones CORS
             */
            createCleanCanvas(sourceCanvas) {
                try {
                    console.log('Creando canvas limpio para PNG...');

                    // Crear nuevo canvas con las mismas dimensiones
                    const cleanCanvas = document.createElement('canvas');
                    cleanCanvas.width = sourceCanvas.width;
                    cleanCanvas.height = sourceCanvas.height;

                    const cleanCtx = cleanCanvas.getContext('2d');
                    const sourceCtx = sourceCanvas.getContext('2d');

                    try {
                        // Intentar copiar usando getImageData (m√©todo m√°s seguro)
                        const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                        cleanCtx.putImageData(imageData, 0, 0);

                        console.log('Canvas PNG limpio creado usando getImageData');
                        return cleanCanvas;

                    } catch (getImageDataError) {
                        console.warn('getImageData fall√≥ para PNG, intentando drawImage:', getImageDataError);

                        try {
                            // Fallback: intentar drawImage
                            cleanCtx.drawImage(sourceCanvas, 0, 0);

                            console.log('Canvas PNG limpio creado usando drawImage');
                            return cleanCanvas;

                        } catch (drawImageError) {
                            console.warn('drawImage tambi√©n fall√≥ para PNG:', drawImageError);

                            // √öltimo recurso: crear canvas b√°sico
                            cleanCtx.fillStyle = '#ffffff';
                            cleanCtx.fillRect(0, 0, cleanCanvas.width, cleanCanvas.height);

                            cleanCtx.fillStyle = '#333333';
                            cleanCtx.font = '20px Arial';
                            cleanCtx.textAlign = 'center';
                            cleanCtx.fillText('Mapa SNIEn', cleanCanvas.width / 2, cleanCanvas.height / 2);

                            console.log('Canvas PNG b√°sico creado como √∫ltimo recurso');
                            return cleanCanvas;
                        }
                    }

                } catch (error) {
                    console.error('Error creando canvas PNG limpio:', error);

                    // Canvas de emergencia
                    const emergencyCanvas = document.createElement('canvas');
                    emergencyCanvas.width = 800;
                    emergencyCanvas.height = 600;
                    const emergencyCtx = emergencyCanvas.getContext('2d');

                    emergencyCtx.fillStyle = '#ffffff';
                    emergencyCtx.fillRect(0, 0, 800, 600);

                    emergencyCtx.fillStyle = '#333333';
                    emergencyCtx.font = '24px Arial';
                    emergencyCtx.textAlign = 'center';
                    emergencyCtx.fillText('Error en exportaci√≥n PNG', 400, 300);

                    return emergencyCanvas;
                }
            }

            /**
             * Procesa un canvas para generar PNG optimizado
             * @param {HTMLCanvasElement} canvas - Canvas con la imagen del mapa
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Promise<Blob>} Archivo PNG generado
             */
            async processPNG(canvas, config) {
                try {
                    console.log('Iniciando procesamiento PNG con DPI:', config.size.dpi);

                    // Validar entrada
                    if (!canvas || canvas.width === 0 || canvas.height === 0) {
                        throw new Error('Canvas inv√°lido para procesamiento PNG');
                    }

                    // Obtener configuraci√≥n de calidad basada en DPI
                    const qualityConfig = this.getQualityConfig(config.size.dpi);

                    // Calcular dimensiones finales
                    const dimensions = this.calculateOutputDimensions(canvas, config);

                    // Crear canvas optimizado
                    const optimizedCanvas = await this.createOptimizedCanvas(canvas, dimensions, qualityConfig);

                    // Aplicar mejoras de imagen si es necesario
                    if (config.size.dpi >= 300) {
                        await this.enhanceImageQuality(optimizedCanvas, qualityConfig);
                    }

                    // Generar blob PNG con compresi√≥n optimizada
                    const pngBlob = await this.generatePNGBlob(optimizedCanvas, qualityConfig);

                    console.log(`PNG procesado: ${dimensions.width}x${dimensions.height}, tama√±o: ${pngBlob.size} bytes`);

                    return pngBlob;

                } catch (error) {
                    console.error('Error en procesamiento PNG:', error);
                    throw new Error('Error procesando PNG: ' + error.message);
                }
            }

            /**
             * Obtiene la configuraci√≥n de calidad basada en DPI
             * @param {number} dpi - Resoluci√≥n en DPI
             * @returns {Object} Configuraci√≥n de calidad
             */
            getQualityConfig(dpi) {
                return this.qualityPresets[dpi] || this.qualityPresets[300];
            }

            /**
             * Calcula las dimensiones de salida basadas en configuraci√≥n
             * @param {HTMLCanvasElement} canvas - Canvas original
             * @param {ExportConfiguration} config - Configuraci√≥n de exportaci√≥n
             * @returns {Object} Dimensiones calculadas
             */
            calculateOutputDimensions(canvas, config) {
                let targetWidth, targetHeight;

                // Si se especifica tama√±o personalizado, usarlo
                if (config.size.preset === 'custom') {
                    targetWidth = config.size.width;
                    targetHeight = config.size.height;
                } else {
                    // Calcular basado en DPI y tama√±o de p√°gina
                    const scaleFactor = config.size.dpi / 96; // 96 DPI es la resoluci√≥n est√°ndar del navegador
                    targetWidth = Math.round(canvas.width * scaleFactor);
                    targetHeight = Math.round(canvas.height * scaleFactor);
                }

                // Aplicar l√≠mites de seguridad para evitar problemas de memoria
                const maxDimension = this.getMaxDimension(config.size.dpi);
                if (targetWidth > maxDimension || targetHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / targetWidth, maxDimension / targetHeight);
                    targetWidth = Math.round(targetWidth * ratio);
                    targetHeight = Math.round(targetHeight * ratio);
                    console.warn(`Dimensiones reducidas por l√≠mites de memoria: ${targetWidth}x${targetHeight}`);
                }

                return {
                    width: targetWidth,
                    height: targetHeight,
                    scaleFactor: targetWidth / canvas.width
                };
            }

            /**
             * Obtiene la dimensi√≥n m√°xima permitida basada en DPI
             * @param {number} dpi - Resoluci√≥n en DPI
             * @returns {number} Dimensi√≥n m√°xima en p√≠xeles
             */
            getMaxDimension(dpi) {
                // L√≠mites conservadores para evitar problemas de memoria
                const limits = {
                    150: 4000,
                    300: 6000,
                    600: 8000
                };
                return limits[dpi] || limits[300];
            }

            /**
             * Crea un canvas optimizado con las dimensiones y calidad especificadas
             * @param {HTMLCanvasElement} sourceCanvas - Canvas original
             * @param {Object} dimensions - Dimensiones objetivo
             * @param {Object} qualityConfig - Configuraci√≥n de calidad
             * @returns {Promise<HTMLCanvasElement>} Canvas optimizado
             */
            async createOptimizedCanvas(sourceCanvas, dimensions, qualityConfig) {
                return new Promise((resolve) => {
                    const outputCanvas = document.createElement('canvas');
                    const ctx = outputCanvas.getContext('2d');

                    // Configurar dimensiones
                    outputCanvas.width = dimensions.width;
                    outputCanvas.height = dimensions.height;

                    // Configurar calidad de renderizado
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = qualityConfig.smoothing;

                    // Aplicar fondo blanco para mejor contraste
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                    // Dibujar imagen escalada con alta calidad
                    ctx.drawImage(sourceCanvas, 0, 0, dimensions.width, dimensions.height);

                    resolve(outputCanvas);
                });
            }

            /**
             * Aplica mejoras de calidad de imagen para altas resoluciones
             * @param {HTMLCanvasElement} canvas - Canvas a mejorar
             * @param {Object} qualityConfig - Configuraci√≥n de calidad
             * @returns {Promise<void>}
             */
            async enhanceImageQuality(canvas, qualityConfig) {
                return new Promise((resolve) => {
                    const ctx = canvas.getContext('2d');

                    // Aplicar filtros de mejora si es necesario
                    if (qualityConfig.compression >= 0.9) {
                        // Para alta calidad, aplicar un ligero sharpening
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const sharpened = this.applySharpeningFilter(imageData);
                        ctx.putImageData(sharpened, 0, 0);
                    }

                    resolve();
                });
            }

            /**
             * Aplica un filtro de sharpening sutil para mejorar la nitidez
             * @param {ImageData} imageData - Datos de imagen original
             * @returns {ImageData} Datos de imagen con sharpening aplicado
             */
            applySharpeningFilter(imageData) {
                // Kernel de sharpening sutil
                const kernel = [
                    0, -0.1, 0,
                    -0.1, 1.4, -0.1,
                    0, -0.1, 0
                ];

                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const output = new Uint8ClampedArray(data.length);

                // Aplicar convoluci√≥n
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        for (let c = 0; c < 3; c++) { // RGB, sin alpha
                            let sum = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                    const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                    sum += data[idx] * kernel[kernelIdx];
                                }
                            }
                            const outputIdx = (y * width + x) * 4 + c;
                            output[outputIdx] = Math.max(0, Math.min(255, sum));
                        }
                        // Copiar canal alpha sin modificar
                        const alphaIdx = (y * width + x) * 4 + 3;
                        output[alphaIdx] = data[alphaIdx];
                    }
                }

                // Copiar bordes sin modificar
                for (let i = 0; i < data.length; i += 4) {
                    const x = (i / 4) % width;
                    const y = Math.floor((i / 4) / width);
                    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                        output[i] = data[i];
                        output[i + 1] = data[i + 1];
                        output[i + 2] = data[i + 2];
                        output[i + 3] = data[i + 3];
                    }
                }

                return new ImageData(output, width, height);
            }

            /**
             * Genera el blob PNG final con compresi√≥n optimizada
             * @param {HTMLCanvasElement} canvas - Canvas procesado
             * @param {Object} qualityConfig - Configuraci√≥n de calidad
             * @returns {Promise<Blob>} Blob PNG generado
             */
            async generatePNGBlob(canvas, qualityConfig) {
                return new Promise((resolve, reject) => {
                    try {
                        // Crear canvas limpio para evitar problemas de CORS
                        const cleanCanvas = this.createCleanCanvas(canvas);

                        // Usar m√°xima calidad para PNG (sin p√©rdida)
                        cleanCanvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('No se pudo generar el blob PNG'));
                                return;
                            }
                            resolve(blob);
                        }, 'image/png', qualityConfig.compression);
                    } catch (error) {
                        reject(new Error('Error generando blob PNG: ' + error.message));
                    }
                });
            }

            /**
             * Valida que el canvas tenga marcadores legibles
             * @param {HTMLCanvasElement} canvas - Canvas a validar
             * @returns {boolean} True si los marcadores son legibles
             */
            validateMarkerReadability(canvas) {
                // Verificaci√≥n b√°sica de que el canvas no est√© completamente vac√≠o
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, Math.min(canvas.width, 100), Math.min(canvas.height, 100));
                const data = imageData.data;

                // Verificar que hay contenido no blanco
                let hasContent = false;
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Si encuentra p√≠xeles que no son blancos puros
                    if (r < 250 || g < 250 || b < 250) {
                        hasContent = true;
                        break;
                    }
                }

                return hasContent;
            }
        }

        /**
         * M√≥dulo principal de exportaci√≥n de mapas
         */
        class MapExporter {
            constructor(map, options = {}) {
                this.map = map;
                this.options = {
                    defaultFormat: 'png',
                    defaultSize: 'A4',
                    defaultDPI: 300,
                    includeMetadata: true,
                    ...options
                };

                this.canvasCapture = new CanvasCapture(map);
                this.pdfGenerator = new PDFGenerator();
                this.pngProcessor = new PNGProcessor();
            }

            /**
             * Crea un canvas limpio copiando los datos p√≠xel por p√≠xel para evitar problemas de CORS
             * @param {HTMLCanvasElement} sourceCanvas - Canvas fuente que puede estar "tainted"
             * @returns {HTMLCanvasElement} Canvas limpio sin restricciones CORS
             */
            createCleanCanvas(sourceCanvas) {
                try {
                    console.log('Creando canvas limpio para evitar problemas CORS...');

                    // Crear nuevo canvas con las mismas dimensiones
                    const cleanCanvas = document.createElement('canvas');
                    cleanCanvas.width = sourceCanvas.width;
                    cleanCanvas.height = sourceCanvas.height;

                    const cleanCtx = cleanCanvas.getContext('2d');
                    const sourceCtx = sourceCanvas.getContext('2d');

                    try {
                        // Intentar copiar usando getImageData (m√©todo m√°s seguro)
                        const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                        cleanCtx.putImageData(imageData, 0, 0);

                        console.log('Canvas limpio creado usando getImageData');
                        return cleanCanvas;

                    } catch (getImageDataError) {
                        console.warn('getImageData fall√≥, intentando drawImage:', getImageDataError);

                        try {
                            // Fallback: intentar drawImage
                            cleanCtx.drawImage(sourceCanvas, 0, 0);

                            console.log('Canvas limpio creado usando drawImage');
                            return cleanCanvas;

                        } catch (drawImageError) {
                            console.warn('drawImage tambi√©n fall√≥:', drawImageError);

                            // √öltimo recurso: crear canvas b√°sico con informaci√≥n
                            cleanCtx.fillStyle = '#ffffff';
                            cleanCtx.fillRect(0, 0, cleanCanvas.width, cleanCanvas.height);

                            cleanCtx.fillStyle = '#333333';
                            cleanCtx.font = '20px Arial';
                            cleanCtx.textAlign = 'center';
                            cleanCtx.fillText('Mapa SNIEn', cleanCanvas.width / 2, cleanCanvas.height / 2);
                            cleanCtx.fillText('(Exportaci√≥n de emergencia)', cleanCanvas.width / 2, cleanCanvas.height / 2 + 30);

                            console.log('Canvas b√°sico creado como √∫ltimo recurso');
                            return cleanCanvas;
                        }
                    }

                } catch (error) {
                    console.error('Error creando canvas limpio:', error);

                    // Canvas de emergencia
                    const emergencyCanvas = document.createElement('canvas');
                    emergencyCanvas.width = 800;
                    emergencyCanvas.height = 600;
                    const emergencyCtx = emergencyCanvas.getContext('2d');

                    emergencyCtx.fillStyle = '#ffffff';
                    emergencyCtx.fillRect(0, 0, 800, 600);

                    emergencyCtx.fillStyle = '#333333';
                    emergencyCtx.font = '24px Arial';
                    emergencyCtx.textAlign = 'center';
                    emergencyCtx.fillText('Error en exportaci√≥n', 400, 280);
                    emergencyCtx.fillText('Mapa SNIEn', 400, 320);

                    return emergencyCanvas;
                }
            }

            /**
             * Exporta el mapa a formato PDF
             * @param {Object} customOptions - Opciones personalizadas de exportaci√≥n
             * @returns {Promise<boolean>} True si la exportaci√≥n fue exitosa
             */
            async exportToPDF(customOptions = {}) {
                try {
                    const config = new ExportConfiguration({
                        format: 'pdf',
                        size: { preset: this.options.defaultSize, dpi: this.options.defaultDPI },
                        ...customOptions
                    });

                    console.log('Iniciando exportaci√≥n PDF con configuraci√≥n:', config);

                    // Capturar el mapa
                    const canvas = await this.canvasCapture.captureMap(config);
                    console.log('Canvas capturado exitosamente:', canvas.width + 'x' + canvas.height);

                    // Obtener metadatos completos
                    const metadata = this.canvasCapture.getMapMetadata();
                    console.log('Metadatos obtenidos:', metadata);

                    // Generar PDF
                    const pdfBlob = await this.pdfGenerator.generatePDF(canvas, config, metadata);
                    console.log('PDF generado exitosamente, tama√±o:', pdfBlob.size, 'bytes');

                    // Generar nombre de archivo descriptivo
                    const filename = this.generateFileName('pdf', metadata.timestamp, metadata);
                    console.log('Nombre de archivo generado:', filename);

                    // Descargar archivo
                    const downloadSuccess = await this.downloadFile(pdfBlob, filename, 'PDF');

                    if (downloadSuccess) {
                        console.log('Exportaci√≥n PDF completada exitosamente');
                        return true;
                    } else {
                        throw new Error('Fall√≥ la descarga del archivo PDF');
                    }

                } catch (error) {
                    console.error('Error detallado en exportaci√≥n PDF:', error);

                    // Mostrar notificaci√≥n de error al usuario
                    this.showNotification(
                        'Error en exportaci√≥n PDF',
                        `No se pudo generar el PDF: ${error.message}`,
                        'error'
                    );

                    throw new Error('Error exportando PDF: ' + error.message);
                }
            }

            /**
             * Exporta el mapa a formato PNG
             * @param {Object} customOptions - Opciones personalizadas de exportaci√≥n
             * @returns {Promise<boolean>} True si la exportaci√≥n fue exitosa
             */
            async exportToPNG(customOptions = {}) {
                try {
                    // Crear configuraci√≥n con valores por defecto optimizados para PNG
                    const config = new ExportConfiguration({
                        format: 'png',
                        size: {
                            dpi: customOptions.size?.dpi || this.options.defaultDPI,
                            preset: customOptions.size?.preset || 'A4',
                            width: customOptions.size?.width,
                            height: customOptions.size?.height
                        },
                        elements: {
                            includeScale: true,
                            includeLegend: true,
                            includeAttribution: true,
                            includeTimestamp: true,
                            ...customOptions.elements
                        },
                        ...customOptions
                    });

                    console.log('Iniciando exportaci√≥n PNG con configuraci√≥n:', config);

                    // Validar configuraci√≥n antes de proceder
                    this.validateExportConfiguration(config);

                    // Capturar el mapa con configuraci√≥n optimizada para PNG
                    const canvas = await this.canvasCapture.captureMap(config);
                    console.log('Canvas capturado exitosamente:', canvas.width + 'x' + canvas.height);

                    // Validar que el canvas tenga contenido v√°lido
                    if (!this.pngProcessor.validateMarkerReadability(canvas)) {
                        console.warn('Advertencia: El canvas puede no tener marcadores visibles');
                    }

                    // Obtener metadatos completos del mapa
                    const metadata = this.canvasCapture.getMapMetadata();
                    console.log('Metadatos obtenidos:', metadata);

                    // Procesar PNG con optimizaciones espec√≠ficas
                    const pngBlob = await this.pngProcessor.processPNG(canvas, config);
                    console.log('PNG procesado exitosamente, tama√±o:', pngBlob.size, 'bytes');

                    // Validar que el archivo generado tenga un tama√±o razonable
                    this.validateFileSize(pngBlob, 'PNG');

                    // Generar nombre de archivo descriptivo con informaci√≥n del mapa
                    const filename = this.generateFileName('png', metadata.timestamp, metadata);
                    console.log('Nombre de archivo generado:', filename);

                    // Descargar archivo autom√°ticamente
                    const downloadSuccess = await this.downloadFile(pngBlob, filename, 'PNG');

                    if (downloadSuccess) {
                        console.log('Exportaci√≥n PNG completada exitosamente');

                        // Mostrar notificaci√≥n de √©xito con detalles
                        this.showNotification(
                            'PNG exportado exitosamente',
                            `Archivo generado: ${filename} (${this.formatFileSize(pngBlob.size)})`,
                            'success'
                        );

                        return true;
                    } else {
                        throw new Error('Fall√≥ la descarga del archivo PNG');
                    }

                } catch (error) {
                    console.error('Error detallado en exportaci√≥n PNG:', error);

                    // Mostrar notificaci√≥n de error espec√≠fica al usuario
                    this.showNotification(
                        'Error en exportaci√≥n PNG',
                        `No se pudo generar el PNG: ${error.message}`,
                        'error'
                    );

                    throw new Error('Error exportando PNG: ' + error.message);
                }
            }

            /**
             * Valida la configuraci√≥n de exportaci√≥n
             * @param {ExportConfiguration} config - Configuraci√≥n a validar
             * @throws {Error} Si la configuraci√≥n es inv√°lida
             */
            validateExportConfiguration(config) {
                // Validar DPI
                const validDPIs = [150, 300, 600];
                if (!validDPIs.includes(config.size.dpi)) {
                    throw new Error(`DPI inv√°lido: ${config.size.dpi}. Valores v√°lidos: ${validDPIs.join(', ')}`);
                }

                // Validar dimensiones personalizadas
                if (config.size.preset === 'custom') {
                    if (!config.size.width || !config.size.height) {
                        throw new Error('Dimensiones personalizadas requeridas para tama√±o custom');
                    }
                    if (config.size.width < 100 || config.size.height < 100) {
                        throw new Error('Dimensiones m√≠nimas: 100x100 p√≠xeles');
                    }
                    if (config.size.width > 8000 || config.size.height > 8000) {
                        throw new Error('Dimensiones m√°ximas: 8000x8000 p√≠xeles');
                    }
                }
            }

            /**
             * Valida el tama√±o del archivo generado
             * @param {Blob} blob - Archivo generado
             * @param {string} format - Formato del archivo
             * @throws {Error} Si el archivo es demasiado grande o peque√±o
             */
            validateFileSize(blob, format) {
                const maxSize = 50 * 1024 * 1024; // 50MB m√°ximo
                const minSize = 1024; // 1KB m√≠nimo

                if (blob.size > maxSize) {
                    throw new Error(`Archivo ${format} demasiado grande: ${this.formatFileSize(blob.size)}. M√°ximo: 50MB`);
                }
                if (blob.size < minSize) {
                    throw new Error(`Archivo ${format} demasiado peque√±o: ${this.formatFileSize(blob.size)}. Puede estar vac√≠o`);
                }
            }

            /**
             * Formatea el tama√±o de archivo para mostrar al usuario
             * @param {number} bytes - Tama√±o en bytes
             * @returns {string} Tama√±o formateado
             */
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            /**
             * Prueba la funcionalidad de captura sin generar archivos
             * @returns {Promise<Object>} Informaci√≥n sobre la captura de prueba
             */
            async testCapture() {
                try {
                    console.log('Iniciando prueba de captura...');

                    // Verificar estado del mapa
                    this.canvasCapture.validateMapState();
                    console.log('Estado del mapa: v√°lido');

                    // Obtener estado de tiles
                    const tileStatus = this.canvasCapture.getTileLoadingStatus();
                    console.log('Estado de tiles:', tileStatus);

                    // Realizar captura de prueba
                    const config = new ExportConfiguration({ format: 'png' });
                    const canvas = await this.canvasCapture.captureMap(config);

                    // Obtener metadatos
                    const metadata = this.canvasCapture.getMapMetadata();

                    return {
                        success: true,
                        canvasSize: { width: canvas.width, height: canvas.height },
                        metadata: metadata,
                        tileStatus: tileStatus
                    };
                } catch (error) {
                    console.error('Error en prueba de captura:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            /**
             * Genera un nombre de archivo descriptivo con timestamp
             * @param {string} format - Formato del archivo (pdf, png)
             * @param {Date} timestamp - Fecha y hora de generaci√≥n
             * @param {Object} metadata - Metadatos del mapa para contexto adicional
             * @returns {string} Nombre del archivo descriptivo
             */
            generateFileName(format, timestamp, metadata = {}) {
                // Crear timestamp legible
                const year = timestamp.getFullYear();
                const month = String(timestamp.getMonth() + 1).padStart(2, '0');
                const day = String(timestamp.getDate()).padStart(2, '0');
                const hours = String(timestamp.getHours()).padStart(2, '0');
                const minutes = String(timestamp.getMinutes()).padStart(2, '0');
                const seconds = String(timestamp.getSeconds()).padStart(2, '0');

                const dateStr = `${year}${month}${day}_${hours}${minutes}${seconds}`;

                // Construir nombre base
                let baseName = 'mapa-snien';

                // A√±adir informaci√≥n contextual si est√° disponible
                if (metadata.selectedInstrumentValue && metadata.selectedInstrumentValue !== '') {
                    const instrumentCode = this.sanitizeForFilename(metadata.selectedInstrumentValue);
                    baseName += `-${instrumentCode}`;
                }

                if (metadata.selectedPlanValue && metadata.selectedPlanValue !== '') {
                    const planCode = this.sanitizeForFilename(metadata.selectedPlanValue);
                    baseName += `-${planCode}`;
                }

                // A√±adir nivel de zoom si es significativo
                if (metadata.zoomLevel && metadata.zoomLevel >= 6) {
                    baseName += `-z${metadata.zoomLevel}`;
                }

                return `${baseName}_${dateStr}.${format}`;
            }

            /**
             * Sanitiza texto para uso en nombres de archivo
             * @param {string} text - Texto a sanitizar
             * @returns {string} Texto sanitizado
             */
            sanitizeForFilename(text) {
                return text
                    .toLowerCase()
                    .replace(/[^a-z0-9]/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-|-$/g, '')
                    .substring(0, 20); // Limitar longitud
            }

            /**
             * Descarga un archivo al dispositivo del usuario con manejo de errores
             * @param {Blob} blob - Contenido del archivo
             * @param {string} filename - Nombre del archivo
             * @param {string} format - Formato del archivo para mensajes de error
             * @returns {Promise<boolean>} True si la descarga fue exitosa
             */
            async downloadFile(blob, filename, format = 'archivo') {
                try {
                    // Verificar que el blob sea v√°lido
                    if (!blob || blob.size === 0) {
                        throw new Error('El archivo generado est√° vac√≠o');
                    }

                    console.log(`Iniciando descarga de ${format}: ${filename} (${blob.size} bytes)`);

                    // Validaciones espec√≠ficas para PNG
                    if (format.toLowerCase() === 'png') {
                        return await this.downloadPNGFile(blob, filename);
                    }

                    // Crear URL del objeto
                    const url = URL.createObjectURL(blob);

                    // Crear elemento de descarga
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.style.display = 'none';

                    // A√±adir al DOM temporalmente
                    document.body.appendChild(link);

                    // Simular click para iniciar descarga
                    link.click();

                    // Limpiar despu√©s de un breve delay
                    setTimeout(() => {
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 100);

                    // Mostrar notificaci√≥n de √©xito
                    this.showNotification(
                        `${format.toUpperCase()} descargado exitosamente`,
                        `El archivo "${filename}" se ha guardado en tu dispositivo.`,
                        'success'
                    );

                    console.log(`Descarga de ${format} completada exitosamente`);
                    return true;

                } catch (error) {
                    console.error(`Error en descarga de ${format}:`, error);

                    // Mostrar notificaci√≥n de error
                    this.showNotification(
                        `Error al descargar ${format.toUpperCase()}`,
                        `No se pudo descargar el archivo: ${error.message}`,
                        'error'
                    );

                    return false;
                }
            }

            /**
             * Descarga espec√≠fica para archivos PNG con validaciones adicionales
             * @param {Blob} pngBlob - Blob del archivo PNG
             * @param {string} filename - Nombre del archivo
             * @returns {Promise<boolean>} True si la descarga fue exitosa
             */
            async downloadPNGFile(pngBlob, filename) {
                try {
                    console.log(`Iniciando descarga PNG especializada: ${filename}`);

                    // Validar que es realmente un PNG
                    if (!pngBlob.type.includes('png')) {
                        console.warn('Advertencia: El blob no tiene tipo PNG, forzando tipo correcto');
                    }

                    // Crear un nuevo blob con el tipo correcto si es necesario
                    const correctedBlob = new Blob([pngBlob], { type: 'image/png' });

                    // Validar calidad de imagen antes de descargar
                    const qualityCheck = await this.validatePNGQuality(correctedBlob);
                    if (!qualityCheck.isValid) {
                        console.warn('Advertencia de calidad PNG:', qualityCheck.warning);
                    }

                    // Crear URL del objeto
                    const url = URL.createObjectURL(correctedBlob);

                    // Crear elemento de descarga con atributos espec√≠ficos para PNG
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.style.display = 'none';

                    // A√±adir atributos para mejor compatibilidad
                    link.setAttribute('type', 'image/png');
                    link.setAttribute('target', '_blank');

                    // A√±adir al DOM temporalmente
                    document.body.appendChild(link);

                    // Usar evento para asegurar que la descarga se complete
                    return new Promise((resolve) => {
                        const cleanup = () => {
                            setTimeout(() => {
                                if (document.body.contains(link)) {
                                    document.body.removeChild(link);
                                }
                                URL.revokeObjectURL(url);
                            }, 1000); // Delay m√°s largo para PNG
                        };

                        // Manejar eventos de descarga
                        link.addEventListener('click', () => {
                            console.log('Descarga PNG iniciada');
                            cleanup();

                            // Mostrar notificaci√≥n espec√≠fica para PNG
                            this.showNotification(
                                'PNG de alta calidad descargado',
                                `Imagen exportada: "${filename}" (${this.formatFileSize(correctedBlob.size)})`,
                                'success'
                            );

                            resolve(true);
                        });

                        // Simular click para iniciar descarga
                        link.click();
                    });

                } catch (error) {
                    console.error('Error en descarga PNG especializada:', error);

                    // Mostrar notificaci√≥n de error espec√≠fica
                    this.showNotification(
                        'Error al descargar PNG',
                        `No se pudo descargar la imagen PNG: ${error.message}`,
                        'error'
                    );

                    return false;
                }
            }

            /**
             * Valida la calidad de un archivo PNG
             * @param {Blob} pngBlob - Blob del PNG a validar
             * @returns {Promise<Object>} Resultado de la validaci√≥n
             */
            async validatePNGQuality(pngBlob) {
                try {
                    // Crear una imagen temporal para validar
                    const img = new Image();
                    const url = URL.createObjectURL(pngBlob);

                    return new Promise((resolve) => {
                        img.onload = () => {
                            URL.revokeObjectURL(url);

                            const result = {
                                isValid: true,
                                width: img.width,
                                height: img.height,
                                fileSize: pngBlob.size
                            };

                            // Validaciones de calidad
                            if (img.width < 100 || img.height < 100) {
                                result.isValid = false;
                                result.warning = 'Imagen demasiado peque√±a para buena legibilidad';
                            } else if (pngBlob.size < 10000) { // Menos de 10KB
                                result.isValid = false;
                                result.warning = 'Archivo muy peque√±o, puede estar vac√≠o o corrupto';
                            } else if (pngBlob.size > 20 * 1024 * 1024) { // M√°s de 20MB
                                result.warning = 'Archivo muy grande, puede tardar en descargarse';
                            }

                            console.log('Validaci√≥n PNG completada:', result);
                            resolve(result);
                        };

                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            resolve({
                                isValid: false,
                                warning: 'No se pudo cargar la imagen PNG generada'
                            });
                        };

                        img.src = url;
                    });

                } catch (error) {
                    console.error('Error validando PNG:', error);
                    return {
                        isValid: false,
                        warning: 'Error validando calidad de PNG: ' + error.message
                    };
                }
            }

            /**
             * Muestra una notificaci√≥n al usuario
             * @param {string} title - T√≠tulo de la notificaci√≥n
             * @param {string} message - Mensaje de la notificaci√≥n
             * @param {string} type - Tipo de notificaci√≥n (success, error, info)
             */
            showNotification(title, message, type = 'info') {
                // Buscar el contenedor de notificaciones
                let container = document.getElementById('notification-container');

                // Crear contenedor si no existe
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'notification-container';
                    container.className = 'notification-container';
                    container.setAttribute('aria-live', 'polite');
                    container.setAttribute('aria-atomic', 'true');
                    document.body.appendChild(container);
                }

                // Crear elemento de notificaci√≥n
                const notification = document.createElement('div');
                notification.className = `notification notification--${type}`;
                notification.setAttribute('role', 'alert');

                notification.innerHTML = `
                    <div class="notification-content">
                        <h4 class="notification-title">${title}</h4>
                        <p class="notification-message">${message}</p>
                    </div>
                    <button type="button" class="notification-close" aria-label="Cerrar notificaci√≥n">
                        <span aria-hidden="true">&times;</span>
                    </button>
                `;

                // A√±adir evento de cierre
                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.addEventListener('click', () => {
                    this.removeNotification(notification);
                });

                // A√±adir al contenedor
                container.appendChild(notification);

                // Auto-remover despu√©s de 5 segundos para notificaciones de √©xito
                if (type === 'success') {
                    setTimeout(() => {
                        if (notification.parentNode) {
                            this.removeNotification(notification);
                        }
                    }, 5000);
                }

                console.log(`Notificaci√≥n mostrada: ${type} - ${title}`);
            }

            /**
             * Remueve una notificaci√≥n con animaci√≥n
             * @param {HTMLElement} notification - Elemento de notificaci√≥n a remover
             */
            removeNotification(notification) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }

            /**
             * Muestra el di√°logo de configuraci√≥n de exportaci√≥n
             */
            showExportDialog() {
                // Esta funcionalidad se implementar√° en tareas posteriores
                console.log('Di√°logo de exportaci√≥n - pendiente de implementaci√≥n');
            }
        }

        // Hacer las clases disponibles globalmente
        window.MapExporter = MapExporter;
        window.ExportConfiguration = ExportConfiguration;
    </script>
    <!-- Export UI Module -->
    <script>
        /**
         * Interfaz de usuario para exportaci√≥n de mapas
         */
        class ExportUI {
            constructor() {
                this.modal = document.getElementById('export-modal');
                this.form = document.getElementById('export-config-form');
                this.exportButtons = {
                    pdf: document.getElementById('export-pdf'),
                    png: document.getElementById('export-png')
                };
                this.modalButtons = {
                    close: this.modal.querySelector('.modal-close'),
                    cancel: this.modal.querySelector('.btn-cancel'),
                    confirm: this.modal.querySelector('.btn-export-confirm')
                };
                this.pageSizeSelect = document.getElementById('page-size');
                this.customSizeSection = document.getElementById('custom-size-section');

                this.currentFormat = 'pdf';
                this.isExporting = false;

                this.initializeEventListeners();
            }

            /**
             * Inicializa los event listeners
             */
            initializeEventListeners() {
                // Botones de exportaci√≥n
                this.exportButtons.pdf.addEventListener('click', () => this.openModal('pdf'));
                this.exportButtons.png.addEventListener('click', () => this.openModal('png'));

                // Botones del modal
                this.modalButtons.close.addEventListener('click', () => this.closeModal());
                this.modalButtons.cancel.addEventListener('click', () => this.closeModal());
                this.modalButtons.confirm.addEventListener('click', () => this.handleExport());

                // Overlay del modal
                this.modal.querySelector('.modal-overlay').addEventListener('click', () => this.closeModal());

                // Escape key para cerrar modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.modal.classList.contains('active')) {
                        this.closeModal();
                    }
                });

                // Cambio de tama√±o de p√°gina
                this.pageSizeSelect.addEventListener('change', () => this.toggleCustomSizeSection());

                // Cambio de formato
                this.form.addEventListener('change', (e) => {
                    if (e.target.name === 'format') {
                        this.currentFormat = e.target.value;
                        this.updateModalForFormat();
                    }
                });

                // Validaci√≥n de campos personalizados
                const customInputs = this.modal.querySelectorAll('#custom-width, #custom-height');
                customInputs.forEach(input => {
                    input.addEventListener('input', () => this.validateCustomSize());
                });
            }

            /**
             * Abre el modal de configuraci√≥n
             * @param {string} format - Formato inicial (pdf o png)
             */
            openModal(format = 'pdf') {
                this.currentFormat = format;

                // Establecer formato seleccionado
                const formatRadio = this.form.querySelector(`input[name="format"][value="${format}"]`);
                if (formatRadio) {
                    formatRadio.checked = true;
                }

                this.updateModalForFormat();
                this.modal.classList.add('active');
                this.modal.setAttribute('aria-hidden', 'false');

                // Focus en el primer elemento
                const firstInput = this.modal.querySelector('input, select, button');
                if (firstInput) {
                    firstInput.focus();
                }
            }

            /**
             * Cierra el modal
             */
            closeModal() {
                if (this.isExporting) return;

                this.modal.classList.remove('active');
                this.modal.setAttribute('aria-hidden', 'true');
            }

            /**
             * Actualiza el modal seg√∫n el formato seleccionado
             */
            updateModalForFormat() {
                const title = this.modal.querySelector('#export-modal-title');
                const confirmButton = this.modalButtons.confirm;

                if (this.currentFormat === 'pdf') {
                    title.textContent = 'Configurar exportaci√≥n PDF';
                    confirmButton.innerHTML = '<span class="btn-text">Exportar PDF</span><span class="btn-spinner" style="display: none;"><span class="spinner-small"></span></span>';
                } else {
                    title.textContent = 'Configurar exportaci√≥n PNG';
                    confirmButton.innerHTML = '<span class="btn-text">Exportar PNG</span><span class="btn-spinner" style="display: none;"><span class="spinner-small"></span></span>';
                }
            }

            /**
             * Muestra/oculta la secci√≥n de tama√±o personalizado
             */
            toggleCustomSizeSection() {
                const isCustom = this.pageSizeSelect.value === 'custom';
                this.customSizeSection.style.display = isCustom ? 'grid' : 'none';

                if (isCustom) {
                    this.validateCustomSize();
                }
            }

            /**
             * Valida los campos de tama√±o personalizado
             */
            validateCustomSize() {
                const widthInput = document.getElementById('custom-width');
                const heightInput = document.getElementById('custom-height');
                const confirmButton = this.modalButtons.confirm;

                const width = parseInt(widthInput.value);
                const height = parseInt(heightInput.value);

                const isValid = width >= 100 && width <= 8000 && height >= 100 && height <= 8000;
                confirmButton.disabled = !isValid;

                if (!isValid) {
                    confirmButton.style.opacity = '0.5';
                    confirmButton.style.cursor = 'not-allowed';
                } else {
                    confirmButton.style.opacity = '1';
                    confirmButton.style.cursor = 'pointer';
                }
            }

            /**
             * Obtiene la configuraci√≥n actual del formulario
             * @returns {Object} Configuraci√≥n de exportaci√≥n
             */
            getConfiguration() {
                const formData = new FormData(this.form);
                const config = {
                    format: formData.get('format') || 'pdf',
                    size: {
                        preset: formData.get('pageSize') || 'A4',
                        dpi: parseInt(formData.get('dpi')) || 300
                    },
                    elements: {
                        includeScale: formData.has('includeScale'),
                        includeLegend: formData.has('includeLegend'),
                        includeAttribution: formData.has('includeAttribution'),
                        includeTimestamp: formData.has('includeTimestamp'),
                        includeTitle: formData.has('includeTitle')
                    },
                    metadata: {
                        title: formData.get('mapTitle') || 'Mapa SNIEn - Sistema Nacional de Informaci√≥n Energ√©tica'
                    }
                };

                // A√±adir dimensiones personalizadas si aplica
                if (config.size.preset === 'custom') {
                    config.size.width = parseInt(formData.get('customWidth')) || 2480;
                    config.size.height = parseInt(formData.get('customHeight')) || 3508;
                }

                return config;
            }

            /**
             * Maneja el proceso de exportaci√≥n
             */
            async handleExport() {
                if (this.isExporting) return;

                try {
                    this.setExportingState(true);

                    const config = this.getConfiguration();

                    // Aqu√≠ se integrar√° con el MapExporter cuando est√© disponible
                    if (window.mapExporter) {
                        if (config.format === 'pdf') {
                            await window.mapExporter.exportToPDF(config);
                        } else {
                            await window.mapExporter.exportToPNG(config);
                        }

                        this.showSuccessMessage(config.format.toUpperCase());
                    } else {
                        throw new Error('Exportador de mapas no disponible');
                    }

                    this.closeModal();
                } catch (error) {
                    console.error('Error durante la exportaci√≥n:', error);
                    this.showErrorMessage(error.message);
                } finally {
                    this.setExportingState(false);
                }
            }

            /**
             * Establece el estado de exportaci√≥n
             * @param {boolean} isExporting - Si est√° exportando
             */
            setExportingState(isExporting) {
                this.isExporting = isExporting;
                const confirmButton = this.modalButtons.confirm;

                if (isExporting) {
                    confirmButton.classList.add('loading');
                    confirmButton.disabled = true;
                } else {
                    confirmButton.classList.remove('loading');
                    confirmButton.disabled = false;
                }
            }

            /**
             * Muestra mensaje de √©xito
             * @param {string} format - Formato exportado
             */
            showSuccessMessage(format) {
                // Esta funcionalidad se implementar√° en la siguiente tarea
                console.log(`Exportaci√≥n ${format} completada exitosamente`);
            }

            /**
             * Muestra mensaje de error
             * @param {string} message - Mensaje de error
             */
            showErrorMessage(message) {
                // Esta funcionalidad se implementar√° en la siguiente tarea
                console.error('Error de exportaci√≥n:', message);
            }
        }

        // Hacer la clase disponible globalmente
        window.ExportUI = ExportUI;
    </script>

    <!-- Notification and Progress System -->
    <script>
        /**
         * Sistema de notificaciones
         */
        class NotificationSystem {
            constructor() {
                this.container = document.getElementById('notification-container');
                this.notifications = new Map();
                this.nextId = 1;
            }

            /**
             * Muestra una notificaci√≥n
             * @param {Object} options - Opciones de la notificaci√≥n
             * @returns {string} ID de la notificaci√≥n
             */
            show(options = {}) {
                const {
                    type = 'info',
                    title = '',
                    message = '',
                    duration = 5000,
                    persistent = false,
                    icon = this.getDefaultIcon(type)
                } = options;

                const id = `notification-${this.nextId++}`;

                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.setAttribute('role', type === 'error' ? 'alert' : 'status');
                notification.innerHTML = `
                    <div class="notification-icon" aria-hidden="true">${icon}</div>
                    <div class="notification-content">
                        ${title ? `<h5 class="notification-title">${title}</h5>` : ''}
                        ${message ? `<p class="notification-message">${message}</p>` : ''}
                    </div>
                    <button type="button" class="notification-close" aria-label="Cerrar notificaci√≥n">
                        <span aria-hidden="true">&times;</span>
                    </button>
                `;

                // Event listener para cerrar
                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.addEventListener('click', () => this.hide(id));

                this.container.appendChild(notification);
                this.notifications.set(id, notification);

                // Mostrar con animaci√≥n
                requestAnimationFrame(() => {
                    notification.classList.add('show');
                });

                // Auto-ocultar si no es persistente
                if (!persistent && duration > 0) {
                    setTimeout(() => this.hide(id), duration);
                }

                return id;
            }

            /**
             * Oculta una notificaci√≥n
             * @param {string} id - ID de la notificaci√≥n
             */
            hide(id) {
                const notification = this.notifications.get(id);
                if (!notification) return;

                notification.classList.remove('show');

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    this.notifications.delete(id);
                }, 300);
            }

            /**
             * Oculta todas las notificaciones
             */
            hideAll() {
                this.notifications.forEach((_, id) => this.hide(id));
            }

            /**
             * Obtiene el icono por defecto seg√∫n el tipo
             * @param {string} type - Tipo de notificaci√≥n
             * @returns {string} Icono
             */
            getDefaultIcon(type) {
                const icons = {
                    success: '‚úÖ',
                    error: '‚ùå',
                    warning: '‚ö†Ô∏è',
                    info: '‚ÑπÔ∏è'
                };
                return icons[type] || icons.info;
            }

            /**
             * M√©todos de conveniencia
             */
            success(title, message, options = {}) {
                return this.show({ ...options, type: 'success', title, message });
            }

            error(title, message, options = {}) {
                return this.show({ ...options, type: 'error', title, message, persistent: true });
            }

            warning(title, message, options = {}) {
                return this.show({ ...options, type: 'warning', title, message });
            }

            info(title, message, options = {}) {
                return this.show({ ...options, type: 'info', title, message });
            }
        }

        /**
         * Sistema de progreso para exportaci√≥n
         */
        class ProgressSystem {
            constructor() {
                this.overlay = document.getElementById('export-progress-overlay');
                this.titleElement = this.overlay.querySelector('.progress-title');
                this.messageElement = this.overlay.querySelector('.progress-message');
                this.fillElement = this.overlay.querySelector('.progress-fill');
                this.percentageElement = this.overlay.querySelector('.progress-percentage');

                this.isVisible = false;
                this.currentProgress = 0;
            }

            /**
             * Muestra el overlay de progreso
             * @param {Object} options - Opciones del progreso
             */
            show(options = {}) {
                const {
                    title = 'Exportando mapa...',
                    message = 'Preparando exportaci√≥n',
                    progress = 0
                } = options;

                this.titleElement.textContent = title;
                this.messageElement.textContent = message;
                this.setProgress(progress);

                this.overlay.style.display = 'flex';
                this.isVisible = true;

                // Prevenir scroll del body
                document.body.style.overflow = 'hidden';
            }

            /**
             * Oculta el overlay de progreso
             */
            hide() {
                this.overlay.style.display = 'none';
                this.isVisible = false;
                this.currentProgress = 0;

                // Restaurar scroll del body
                document.body.style.overflow = '';
            }

            /**
             * Actualiza el progreso
             * @param {number} progress - Progreso (0-100)
             * @param {string} message - Mensaje opcional
             */
            setProgress(progress, message = null) {
                this.currentProgress = Math.max(0, Math.min(100, progress));

                this.fillElement.style.width = `${this.currentProgress}%`;
                this.percentageElement.textContent = `${Math.round(this.currentProgress)}%`;

                if (message) {
                    this.messageElement.textContent = message;
                }
            }

            /**
             * Actualiza solo el mensaje
             * @param {string} message - Nuevo mensaje
             */
            setMessage(message) {
                this.messageElement.textContent = message;
            }

            /**
             * Actualiza el t√≠tulo
             * @param {string} title - Nuevo t√≠tulo
             */
            setTitle(title) {
                this.titleElement.textContent = title;
            }

            /**
             * Simula progreso autom√°tico
             * @param {number} duration - Duraci√≥n en ms
             * @param {Function} callback - Callback al completar
             */
            simulateProgress(duration = 3000, callback = null) {
                const steps = 50;
                const interval = duration / steps;
                let step = 0;

                const timer = setInterval(() => {
                    step++;
                    const progress = (step / steps) * 100;
                    this.setProgress(progress);

                    if (step >= steps) {
                        clearInterval(timer);
                        if (callback) callback();
                    }
                }, interval);

                return timer;
            }
        }

        /**
         * Integraci√≥n con ExportUI para mostrar progreso y notificaciones
         */
        if (window.ExportUI) {
            const originalExportUI = window.ExportUI;

            window.ExportUI = class extends originalExportUI {
                constructor() {
                    super();
                    this.notifications = new NotificationSystem();
                    this.progress = new ProgressSystem();
                }

                /**
                 * Maneja el proceso de exportaci√≥n con indicadores de progreso
                 */
                async handleExport() {
                    if (this.isExporting) return;

                    try {
                        this.setExportingState(true);

                        const config = this.getConfiguration();
                        const format = config.format.toUpperCase();

                        // Mostrar progreso
                        this.progress.show({
                            title: `Exportando ${format}...`,
                            message: 'Preparando captura del mapa'
                        });

                        // Simular progreso de captura
                        this.progress.setProgress(10, 'Capturando imagen del mapa');

                        // Aqu√≠ se integrar√° con el MapExporter cuando est√© disponible
                        if (window.mapExporter) {
                            this.progress.setProgress(30, 'Procesando imagen');

                            if (config.format === 'pdf') {
                                this.progress.setProgress(60, 'Generando archivo PDF');
                                await window.mapExporter.exportToPDF(config);
                            } else {
                                this.progress.setProgress(60, 'Optimizando imagen PNG');
                                await window.mapExporter.exportToPNG(config);
                            }

                            this.progress.setProgress(90, 'Preparando descarga');

                            // Simular finalizaci√≥n
                            await new Promise(resolve => setTimeout(resolve, 500));
                            this.progress.setProgress(100, 'Completado');

                            await new Promise(resolve => setTimeout(resolve, 500));

                            this.showSuccessMessage(format);
                        } else {
                            throw new Error('Exportador de mapas no disponible');
                        }

                        this.closeModal();
                    } catch (error) {
                        console.error('Error durante la exportaci√≥n:', error);
                        this.showErrorMessage(error.message);
                    } finally {
                        this.progress.hide();
                        this.setExportingState(false);
                    }
                }

                /**
                 * Muestra mensaje de √©xito
                 * @param {string} format - Formato exportado
                 */
                showSuccessMessage(format) {
                    this.notifications.success(
                        'Exportaci√≥n completada',
                        `El archivo ${format} se ha descargado correctamente a tu dispositivo.`,
                        { duration: 6000 }
                    );
                }

                /**
                 * Muestra mensaje de error
                 * @param {string} message - Mensaje de error
                 */
                showErrorMessage(message) {
                    this.notifications.error(
                        'Error en la exportaci√≥n',
                        `No se pudo completar la exportaci√≥n: ${message}`,
                        { persistent: true }
                    );
                }

                /**
                 * Establece el estado de exportaci√≥n con indicadores visuales
                 * @param {boolean} isExporting - Si est√° exportando
                 */
                setExportingState(isExporting) {
                    super.setExportingState(isExporting);

                    // A√±adir clase de loading a los botones de exportaci√≥n
                    Object.values(this.exportButtons).forEach(button => {
                        if (isExporting) {
                            button.classList.add('btn-export--loading');
                            button.disabled = true;
                        } else {
                            button.classList.remove('btn-export--loading');
                            button.disabled = false;
                        }
                    });
                }
            };
        }

        // Hacer las clases disponibles globalmente
        window.NotificationSystem = NotificationSystem;
        window.ProgressSystem = ProgressSystem;
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const MAP_CONTAINER_ID = 'map';
            const SHEET_CSV = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS4QU5BVBEHmewrNOLjaKoqca3qH16zYKXzvYfMwhrMiW1mR4yUHNJlbIjDhQuDmWtN803Da7r4SZV6/pub?gid=0&single=true&output=csv';
            const REFRESH_MS = 0; // Cambia a 300000 para 5 minutos, por ejemplo.

            const mapContainer = document.getElementById(MAP_CONTAINER_ID);
            if (!mapContainer) {
                console.error('No se encontr&oacute; el contenedor del mapa.');
                return;
            }

            const preloader = document.getElementById('preloader');
            const lastUpdatedEl = document.getElementById('last-updated');
            const refreshBtn = document.getElementById('refresh-data');

            const mexicoBounds = L.latLngBounds(
                [14.0, -118.0],
                [33.5, -86.0]
            );

            const mapTilerKeys = {
                personal: 'jAAFQsMBZ9a6VIm2dCwg',
                amigo: 'xRR3xCujdkUjxkDqlNTG'
            };

            const mapTilerAttribution = '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
            const fallbackAttribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>';

            function hasMapTilerSDK() {
                return typeof L !== 'undefined' &&
                    typeof L.maptiler !== 'undefined' &&
                    typeof L.maptiler.maptilerLayer === 'function';
            }

            function buildMapTilerUrl(styleId, apiKey) {
                return 'https://api.maptiler.com/maps/' + styleId + '/256/{z}/{x}/{y}.png?key=' + apiKey;
            }

            let map;

            function createMapTilerLayer(styleId, keyName, fallbackUrl, name) {
                const apiKey = mapTilerKeys[keyName];
                const fallbackLayer = fallbackUrl ? L.tileLayer(fallbackUrl, {
                    attribution: fallbackAttribution,
                    maxZoom: 18
                }) : null;

                if (!apiKey) {
                    console.warn('No existe API key para', keyName, '; usando fallback para', name);
                    return fallbackLayer;
                }

                if (hasMapTilerSDK()) {
                    try {
                        const layer = L.maptiler.maptilerLayer({
                            apiKey: apiKey,
                            style: styleId,
                            maxZoom: 18
                        });
                        if (layer && layer.options && !layer.options.maxZoom) {
                            layer.options.maxZoom = 18;
                        }
                        return layer;
                    } catch (error) {
                        console.warn('Error creando ' + name + ' con MapTiler SDK:', error);
                    }
                } else {
                    console.warn('MapTiler SDK no disponible; usando fallback para ' + name);
                }

                if (fallbackLayer) {
                    return fallbackLayer;
                }

                return L.tileLayer(buildMapTilerUrl(styleId, apiKey), {
                    attribution: mapTilerAttribution,
                    maxZoom: 18
                });
            }

            const fallbackLight = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
            const fallbackDark = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';

            const instrumentDescriptions = {
                estrategia: {
                    title: 'Estrategia Nacional de Transici\u00F3n Energ\u00E9tica',
                    tagline: 'Horizonte: mediano (15 a\u00F1os) y largo plazo (30 a\u00F1os)',
                    description: 'Instrumento rector de la pol\u00EDtica nacional que gu\u00EDa la transici\u00F3n energ\u00E9tica y el aprovechamiento sustentable de la energ\u00EDa.',
                    bullets: [
                        'Incluye diagn\u00F3stico del sector energ\u00E9tico, metas y escenarios a mediano y largo plazo.',
                        'Define responsabilidades institucionales y l\u00EDneas de acci\u00F3n estrat\u00E9gicas.',
                        'Prioriza transici\u00F3n energ\u00E9tica, energ\u00EDas limpias, justicia energ\u00E9tica, innovaci\u00F3n y formaci\u00F3n de talento.'
                    ]
                },
                prosener: {
                    title: 'Programa Sectorial de Energ\u00EDa (PROSENER)',
                    tagline: 'Horizonte: corto plazo (sexenal)',
                    description: 'Programa que aterriza los objetivos del Plan Nacional de Desarrollo para el sector energ\u00E9tico durante la administraci\u00F3n en curso.',
                    bullets: [
                        'Orienta acciones y metas de corto plazo alineadas con el PND.',
                        'Permite evaluar avances de pol\u00EDtica p\u00FAblica durante el periodo gubernamental.',
                        'Sirve como gu\u00EDa operativa para dependencias y entidades del sector.'
                    ]
                },
                platease: {
                    title: 'Plan para la Transici\u00F3n Energ\u00E9tica y el Aprovechamiento Sustentable de la Energ\u00EDa (PLATEASE)',
                    tagline: 'Horizonte: 15 a\u00F1os',
                    description: 'Documento que articula programas y proyectos derivados de la Estrategia, con \u00E9nfasis en transici\u00F3n energ\u00E9tica y eficiencia.',
                    bullets: [
                        'Establece actividades y proyectos prioritarios derivados de la Estrategia.',
                        'Se actualiza anualmente para mantener vigentes sus acciones.',
                        'Coordina esfuerzos institucionales para aprovechar energ\u00EDa de manera sustentable.'
                    ]
                },
                pladese: {
                    title: 'Plan de Desarrollo del Sector El\u00E9ctrico (PLADESE)',
                    tagline: 'Horizonte: 15 a\u00F1os',
                    description: 'Plan para modernizar y expandir la infraestructura del sistema el\u00E9ctrico nacional.',
                    bullets: [
                        'Define programas vinculantes de inversi\u00F3n p\u00FAblica para generar, modernizar y retirar centrales el\u00E9ctricas.',
                        'Establece la expansi\u00F3n de la Red Nacional de Transmisi\u00F3n y las Redes Generales de Distribuci\u00F3n.',
                        'Integra acciones de servicios conexos, eficiencia energ\u00E9tica, sostenibilidad y transici\u00F3n energ\u00E9tica con actualizaci\u00F3n anual.'
                    ]
                },
                pladeshi: {
                    title: 'Plan de Desarrollo del Sector Hidrocarburos (PLADESHi)',
                    tagline: 'Horizonte: 15 a\u00F1os',
                    description: 'Documento que gu\u00EDa el desarrollo y modernizaci\u00F3n de la infraestructura de hidrocarburos.',
                    bullets: [
                        'Incluye programas para exploraci\u00F3n, extracci\u00F3n, almacenamiento, transporte y distribuci\u00F3n.',
                        'Aborda gas natural, petrol\u00EDferos y petroqu\u00EDmica con enfoque a eficiencia y transici\u00F3n energ\u00E9tica.',
                        'Se actualiza anualmente para alinear inversiones y proyectos estrat\u00E9gicos.'
                    ]
                }
            };

            const planDescriptions = {
                pvirce: {
                    title: 'Programas Vinculantes para la Instalaci\u00F3n y Retiro de Centrales El\u00E9ctricas (PVIRCE)',
                    description: 'Instrumento que ordena, en coordinaci\u00F3n con el Estado, la instalaci\u00F3n y retiro de centrales para garantizar confiabilidad y sostenibilidad del sistema el\u00E9ctrico.'
                },
                pam: {
                    title: 'Programas de Ampliaci\u00F3n y Modernizaci\u00F3n (PAM) de la RNT y RGD',
                    description: 'Programas que detallan las inversiones necesarias para ampliar y modernizar la Red Nacional de Transmisi\u00F3n y las Redes Generales de Distribuci\u00F3n.'
                },
                sistrangas: {
                    title: 'Plan Quinquenal de Expansi\u00F3n del SISTRANGAS',
                    description: 'Plan a cinco a\u00F1os que proyecta ampliaciones del Sistema de Transporte y Almacenamiento Nacional Integrado de Gas Natural.'
                },
                petroleo: {
                    title: 'Plan Quinquenal de Expansi\u00F3n y Optimizaci\u00F3n de Infraestructura de Petr\u00F3leo y Petrol\u00EDferos',
                    description: 'Plan a cinco a\u00F1os que define la expansi\u00F3n y optimizaci\u00F3n del transporte por ducto y almacenamiento de petr\u00F3leo y petrol\u00EDferos.'
                }
            };

            const layerConfigs = {
                'sener-azul': {
                    label: 'SENER Azul',
                    layer: createMapTilerLayer('0198a42c-5e08-77a1-9773-763ee4e12b32', 'personal', fallbackLight, 'SENER Azul')
                },
                'sener-light': {
                    label: 'SENER Light',
                    layer: createMapTilerLayer('0198a9af-dc7c-79d3-8316-a80767ad1d0f', 'amigo', fallbackLight, 'SENER Light')
                },
                'sener-oscuro': {
                    label: 'SENER Oscuro',
                    layer: createMapTilerLayer('0198a9f0-f135-7991-aaec-bea71681556e', 'amigo', fallbackDark, 'SENER Oscuro')
                },
                'google-satelite': {
                    label: 'Google Sat\u00E9lite',
                    layer: L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        attribution: '&copy; Google',
                        maxZoom: 20
                    })
                }
            };

            const baseLayers = {};
            const baseLayersForControl = {};

            Object.entries(layerConfigs).forEach(function ([key, config]) {
                if (config.layer) {
                    baseLayers[key] = config.layer;
                    baseLayersForControl[config.label] = config.layer;
                }
            });

            const baseKeys = Object.keys(baseLayers);
            if (!baseKeys.length) {
                console.error('No hay mapas base disponibles.');
                return;
            }

            const defaultBaseKey = baseLayers['sener-azul'] ? 'sener-azul' : baseKeys[0];
            const activeBaseLayer = baseLayers[defaultBaseKey];

            map = L.map(MAP_CONTAINER_ID, {
                center: [24.1, -102],
                zoom: 5,
                minZoom: 4,
                maxZoom: 18,
                maxBounds: mexicoBounds,
                maxBoundsViscosity: 1,
                layers: activeBaseLayer ? [activeBaseLayer] : [],
                zoomControl: false,
                preferCanvas: true
            });

            L.control.zoom({ position: 'bottomright' }).addTo(map);

            // Crear capa de graticule (l√≠neas de latitud y longitud)
            function createGraticule() {
                const graticuleLayer = L.layerGroup();

                // L√≠neas de latitud (horizontales) - cada 5 grados
                for (let lat = 15; lat <= 30; lat += 5) {
                    const latlngs = [];
                    for (let lng = -118; lng <= -86; lng += 0.5) {
                        latlngs.push([lat, lng]);
                    }

                    // Crear l√≠nea m√°s visible
                    L.polyline(latlngs, {
                        color: '#333333',
                        weight: 1.5,
                        opacity: 0.8,
                        dashArray: '3, 6'
                    }).addTo(graticuleLayer);
                }

                // L√≠neas de longitud (verticales) - cada 5 grados
                for (let lng = -115; lng <= -90; lng += 5) {
                    const latlngs = [];
                    for (let lat = 14; lat <= 33; lat += 0.5) {
                        latlngs.push([lat, lng]);
                    }

                    // Crear l√≠nea m√°s visible
                    L.polyline(latlngs, {
                        color: '#333333',
                        weight: 1.5,
                        opacity: 0.8,
                        dashArray: '3, 6'
                    }).addTo(graticuleLayer);
                }

                return graticuleLayer;
            }

            // Capa ligera para mostrar etiquetas de coordenadas junto a las l?neas de graticule
            const GraticuleLabels = L.Layer.extend({
                initialize: function (options = {}) {
                    L.setOptions(this, options);
                },

                onAdd: function (map) {
                    this._map = map;
                    this._container = L.DomUtil.create('div', 'graticule-labels-control', map.getContainer());
                    this._container.style.pointerEvents = 'none';

                    this._topLabels = L.DomUtil.create('div', 'graticule-labels-top', this._container);
                    this._bottomLabels = L.DomUtil.create('div', 'graticule-labels-bottom', this._container);
                    this._leftLabels = L.DomUtil.create('div', 'graticule-labels-left', this._container);
                    this._rightLabels = L.DomUtil.create('div', 'graticule-labels-right', this._container);

                    map.on('move zoom viewreset resize', this._updateLabels, this);
                    if (this.options.targetLayer) {
                        map.on('overlayadd overlayremove', this._updateLabels, this);
                    }

                    this._updateLabels();
                },

                onRemove: function (map) {
                    map.off('move zoom viewreset resize', this._updateLabels, this);
                    if (this.options.targetLayer) {
                        map.off('overlayadd overlayremove', this._updateLabels, this);
                    }

                    if (this._container) {
                        L.DomUtil.remove(this._container);
                        this._container = null;
                        this._topLabels = null;
                        this._bottomLabels = null;
                        this._leftLabels = null;
                        this._rightLabels = null;
                    }

                    this._map = null;
                },

                _formatLongitude: function (lng) {
                    const hemisphere = lng < 0 ? 'O' : 'E';
                    const absValue = Math.abs(Math.round(lng));
                    return `${absValue}&deg;00'00" ${hemisphere}`;
                },

                _formatLatitude: function (lat) {
                    const hemisphere = lat >= 0 ? 'N' : 'S';
                    const absValue = Math.abs(Math.round(lat));
                    return `${absValue}&deg;00'00" ${hemisphere}`;
                },

                _clearLabels: function () {
                    if (!this._topLabels) {
                        return;
                    }
                    this._topLabels.innerHTML = '';
                    this._bottomLabels.innerHTML = '';
                    this._leftLabels.innerHTML = '';
                    this._rightLabels.innerHTML = '';
                },

                _updateLabels: function () {
                    if (!this._map || !this._container) {
                        return;
                    }

                    const shouldShow = !this.options.targetLayer || this._map.hasLayer(this.options.targetLayer);
                    this._container.style.display = shouldShow ? '' : 'none';

                    if (!shouldShow) {
                        this._clearLabels();
                        return;
                    }

                    const bounds = this._map.getBounds();
                    const size = this._map.getSize();
                    const north = bounds.getNorth();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const east = bounds.getEast();

                    this._clearLabels();

                    for (let lng = -115; lng <= -90; lng += 5) {
                        if (lng < west - 0.1 || lng > east + 0.1) {
                            continue;
                        }

                        const topPoint = this._map.latLngToContainerPoint([north, lng]);
                        if (topPoint.x < 0 || topPoint.x > size.x) {
                            continue;
                        }

                        const labelText = this._formatLongitude(lng);

                        const topLabel = L.DomUtil.create('div', 'graticule-label-item', this._topLabels);
                        topLabel.innerHTML = labelText;
                        topLabel.style.left = topPoint.x + 'px';
                        topLabel.style.position = 'absolute';

                        const bottomLabel = L.DomUtil.create('div', 'graticule-label-item', this._bottomLabels);
                        bottomLabel.innerHTML = labelText;
                        bottomLabel.style.left = topPoint.x + 'px';
                        bottomLabel.style.position = 'absolute';
                    }

                    for (let lat = 15; lat <= 30; lat += 5) {
                        if (lat < south - 0.1 || lat > north + 0.1) {
                            continue;
                        }

                        const leftPoint = this._map.latLngToContainerPoint([lat, west]);
                        if (leftPoint.y < 0 || leftPoint.y > size.y) {
                            continue;
                        }

                        const labelText = this._formatLatitude(lat);

                        const leftLabel = L.DomUtil.create('div', 'graticule-label-item', this._leftLabels);
                        leftLabel.innerHTML = labelText;
                        leftLabel.style.top = leftPoint.y + 'px';
                        leftLabel.style.position = 'absolute';

                        const rightPoint = this._map.latLngToContainerPoint([lat, east]);
                        const rightLabel = L.DomUtil.create('div', 'graticule-label-item', this._rightLabels);
                        rightLabel.innerHTML = labelText;
                        rightLabel.style.top = rightPoint.y + 'px';
                        rightLabel.style.position = 'absolute';
                    }
                }
            });

            const graticuleLayer = createGraticule();
            const graticuleLabels = new GraticuleLabels({ targetLayer: graticuleLayer });

            graticuleLayer.addTo(map);
            graticuleLabels.addTo(map);

            // Crear overlays para el control de capas
            const overlays = {
                'Graticule (Lat/Long)': graticuleLayer
            };

            if (Object.keys(baseLayersForControl).length) {
                L.control.layers(baseLayersForControl, overlays, { position: 'topright', collapsed: true }).addTo(map);
            }

            // El mapa base se maneja ahora completamente desde el control de capas de Leaflet
            let currentBaseLayer = activeBaseLayer || null;

            map.fitBounds(mexicoBounds.pad(-0.15));
            map.on('zoomend', function () {
                if (map.getZoom() < 4) {
                    map.setZoom(4);
                }
            });

            const markersLayer = L.layerGroup().addTo(map);

            function renderDetails(container, info, placeholderText) {
                if (!container) {
                    return;
                }
                container.innerHTML = '';

                if (!info) {
                    container.innerHTML = '<p class="placeholder">' + placeholderText + '</p>';
                    return;
                }

                const title = document.createElement('h4');
                title.textContent = info.title;
                container.appendChild(title);

                if (info.tagline) {
                    const tagline = document.createElement('p');
                    tagline.className = 'tagline';
                    tagline.textContent = info.tagline;
                    container.appendChild(tagline);
                }

                const paragraph = document.createElement('p');
                paragraph.textContent = info.description;
                container.appendChild(paragraph);

                if (Array.isArray(info.bullets) && info.bullets.length) {
                    const list = document.createElement('ul');
                    info.bullets.forEach(function (item) {
                        const li = document.createElement('li');
                        li.textContent = item;
                        list.appendChild(li);
                    });
                    container.appendChild(list);
                }
            }

            function togglePreloader(show) {
                if (!preloader) {
                    return;
                }
                preloader.classList.toggle('hidden', !show);
            }

            function updateTimestamp() {
                if (!lastUpdatedEl) {
                    return;
                }
                const now = new Date();
                lastUpdatedEl.textContent = now.toLocaleString('es-MX', {
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            function drawRows(rows) {
                markersLayer.clearLayers();
                const bounds = [];
                rows.forEach(function (row) {
                    const latRaw = row.lat || row.Lat || row.latitude || '';
                    const lngRaw = row.lng || row.Lng || row.lon || row.longitude || '';
                    const lat = parseFloat(latRaw.toString().replace(',', '.'));
                    const lng = parseFloat(lngRaw.toString().replace(',', '.'));
                    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                        return;
                    }
                    const title = row.titulo || row.Titulo || 'Registro';
                    const description = row.descripcion || row.Descripcion || '';
                    const popup = [
                        '<div><span class="badge">Hoja</span></div>',
                        '<strong>' + title + '</strong>',
                        description ? '<div class="description">' + description + '</div>' : '',
                        '<small>(' + lat.toFixed(5) + ', ' + lng.toFixed(5) + ')</small>'
                    ].filter(Boolean).join('');
                    L.marker([lat, lng]).bindPopup(popup).addTo(markersLayer);
                    bounds.push([lat, lng]);
                });
                if (bounds.length) {
                    const calculatedBounds = L.latLngBounds(bounds);
                    map.fitBounds(bounds.length === 1 ? calculatedBounds.pad(0.25) : calculatedBounds.pad(0.2));
                }
            }

            async function loadAndRender(options) {
                const silent = options && options.silent;
                if (!silent) {
                    togglePreloader(true);
                }
                try {
                    const cacheBuster = 'cb=' + Date.now();
                    const url = SHEET_CSV + (SHEET_CSV.includes('?') ? '&' : '?') + cacheBuster;
                    const response = await fetch(url, { cache: 'no-store' });
                    const csvText = await response.text();
                    const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
                    drawRows(parsed.data);
                    updateTimestamp();
                } catch (error) {
                    console.error('Fallo de carga:', error);
                } finally {
                    togglePreloader(false);
                }
            }

            if (refreshBtn) {
                refreshBtn.addEventListener('click', function () {
                    loadAndRender({ silent: false });
                });
            }

            // Los selectores de instrumentos y planes se han eliminado
            // Las capas se manejan ahora desde el control de capas de Leaflet

            loadAndRender({ silent: false });

            if (REFRESH_MS > 0) {
                setInterval(function () {
                    loadAndRender({ silent: true });
                }, REFRESH_MS);
            }

            // Inicializar sistema de exportaci√≥n de mapas
            let mapExporter;
            let exportUI;

            try {
                mapExporter = new MapExporter(map);
                console.log('MapExporter inicializado correctamente');

                // Hacer disponible globalmente para pruebas
                window.mapExporter = mapExporter;

                // Inicializar la interfaz de exportaci√≥n
                exportUI = new ExportUI();
                console.log('ExportUI inicializado correctamente');

                // Hacer disponible globalmente
                window.exportUI = exportUI;

                // Probar la funcionalidad de captura despu√©s de que el mapa est√© completamente cargado
                setTimeout(async () => {
                    try {
                        const testResult = await mapExporter.testCapture();
                        console.log('Prueba de captura:', testResult);
                    } catch (error) {
                        console.warn('Error en prueba de captura:', error);
                    }
                }, 2000);

            } catch (error) {
                console.error('Error inicializando sistema de exportaci√≥n:', error);
            }
        });
    </script>
</body>

</html>
